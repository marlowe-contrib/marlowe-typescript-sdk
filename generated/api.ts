/* tslint:disable */
/* eslint-disable */
/**
 * Marlowe Runtime REST API
 * REST API for Marlowe Runtime
 *
 * The version of the OpenAPI document: 0.0.5.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * @type Action
 * A contract which becomes active when an action occurs.
 * @export
 */
export type Action = ActionOneOf | ActionOneOf1 | ActionOneOf2;

/**
 * @type ActionObject
 * A contract which becomes active when an action occurs.
 * @export
 */
export type ActionObject = ActionObjectOneOf | ActionOneOf | ActionOneOf1 | ActionOneOf2;

/**
 * 
 * @export
 * @interface ActionObjectOneOf
 */
export interface ActionObjectOneOf {
    /**
     * An arbitrary text identifier for an object in a Marlowe object bundle.
     * @type {string}
     * @memberof ActionObjectOneOf
     */
    'ref': string;
}
/**
 * 
 * @export
 * @interface ActionOneOf
 */
export interface ActionOneOf {
    /**
     * 
     * @type {Value}
     * @memberof ActionOneOf
     */
    'deposits': Value;
    /**
     * 
     * @type {Party}
     * @memberof ActionOneOf
     */
    'into_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof ActionOneOf
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof ActionOneOf
     */
    'party': Party;
}
/**
 * 
 * @export
 * @interface ActionOneOf1
 */
export interface ActionOneOf1 {
    /**
     * 
     * @type {Array<Bound>}
     * @memberof ActionOneOf1
     */
    'choose_between': Array<Bound>;
    /**
     * 
     * @type {ChoiceId}
     * @memberof ActionOneOf1
     */
    'for_choice': ChoiceId;
}
/**
 * 
 * @export
 * @interface ActionOneOf2
 */
export interface ActionOneOf2 {
    /**
     * 
     * @type {Observation}
     * @memberof ActionOneOf2
     */
    'notify_if': Observation;
}
/**
 * Applicable Inputs for a given contract
 * @export
 * @interface ApplicableInputs
 */
export interface ApplicableInputs {
    /**
     * 
     * @type {Array<CanChoose>}
     * @memberof ApplicableInputs
     */
    'choices': Array<CanChoose>;
    /**
     * 
     * @type {Array<CanDeposit>}
     * @memberof ApplicableInputs
     */
    'deposits': Array<CanDeposit>;
    /**
     * 
     * @type {CanNotify}
     * @memberof ApplicableInputs
     */
    'notify'?: CanNotify;
}
/**
 * 
 * @export
 * @interface ApplyInputsResponse
 */
export interface ApplyInputsResponse {
    /**
     * 
     * @type {ApplyInputsResponseLinks}
     * @memberof ApplyInputsResponse
     */
    'links': ApplyInputsResponseLinks;
    /**
     * 
     * @type {ApplyInputsTxEnvelope}
     * @memberof ApplyInputsResponse
     */
    'resource': ApplyInputsTxEnvelope;
}
/**
 * 
 * @export
 * @interface ApplyInputsResponseLinks
 */
export interface ApplyInputsResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof ApplyInputsResponseLinks
     */
    'transaction'?: string;
}
/**
 * The \"type\" property of \"tx\" must be \"Tx BabbageEra\" or \"Tx ConwayEra\"
 * @export
 * @interface ApplyInputsTxEnvelope
 */
export interface ApplyInputsTxEnvelope {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ApplyInputsTxEnvelope
     */
    'contractId': string;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof ApplyInputsTxEnvelope
     */
    'transactionId': string;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof ApplyInputsTxEnvelope
     */
    'tx': TextEnvelope;
}
/**
 * 
 * @export
 * @interface AssetId
 */
export interface AssetId {
    /**
     * 
     * @type {string}
     * @memberof AssetId
     */
    'assetName': string;
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof AssetId
     */
    'policyId': string;
}
/**
 * 
 * @export
 * @interface Assets
 */
export interface Assets {
    /**
     * 
     * @type {number}
     * @memberof Assets
     */
    'lovelace': number;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number | undefined; } | undefined; }}
     * @memberof Assets
     */
    'tokens': { [key: string]: { [key: string]: number | undefined; } | undefined; };
}
/**
 * 
 * @export
 * @interface BlockHeader
 */
export interface BlockHeader {
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    'blockHeaderHash': string;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    'blockNo': number;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    'slotNo': number;
}
/**
 * An inclusive range of values for a choice.
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * 
     * @type {number}
     * @memberof Bound
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof Bound
     */
    'to': number;
}
/**
 * Choice Inputs that can be applied for a given contract
 * @export
 * @interface CanChoose
 */
export interface CanChoose {
    /**
     * 
     * @type {Array<Bound>}
     * @memberof CanChoose
     */
    'can_choose_between': Array<Bound>;
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanChoose
     */
    'case_index': number;
    /**
     * 
     * @type {ChoiceId}
     * @memberof CanChoose
     */
    'for_choice': ChoiceId;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanChoose
     */
    'is_merkleized_continuation': boolean;
}
/**
 * Deposit Input that can be applied for a given contract
 * @export
 * @interface CanDeposit
 */
export interface CanDeposit {
    /**
     * 
     * @type {number}
     * @memberof CanDeposit
     */
    'can_deposit': number;
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanDeposit
     */
    'case_index': number;
    /**
     * 
     * @type {Party}
     * @memberof CanDeposit
     */
    'into_account': Party;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanDeposit
     */
    'is_merkleized_continuation': boolean;
    /**
     * 
     * @type {Token}
     * @memberof CanDeposit
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof CanDeposit
     */
    'party': Party;
}
/**
 * Notify Input tha can be applied for a given contract
 * @export
 * @interface CanNotify
 */
export interface CanNotify {
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanNotify
     */
    'case_index': number;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanNotify
     */
    'is_merkleized_continuation': boolean;
}
/**
 * @type Case
 * A contract which becomes active when an action occurs.
 * @export
 */
export type Case = CaseOneOf | CaseOneOf1;

/**
 * @type CaseObject
 * A contract which becomes active when an action occurs.
 * @export
 */
export type CaseObject = CaseObjectOneOf | CaseObjectOneOf1;

/**
 * 
 * @export
 * @interface CaseObjectOneOf
 */
export interface CaseObjectOneOf {
    /**
     * 
     * @type {ActionObject}
     * @memberof CaseObjectOneOf
     */
    'case': ActionObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof CaseObjectOneOf
     */
    'then': ContractObject;
}
/**
 * 
 * @export
 * @interface CaseObjectOneOf1
 */
export interface CaseObjectOneOf1 {
    /**
     * 
     * @type {ActionObject}
     * @memberof CaseObjectOneOf1
     */
    'case': ActionObject;
    /**
     * 
     * @type {string}
     * @memberof CaseObjectOneOf1
     */
    'merkleized_then': string;
}
/**
 * 
 * @export
 * @interface CaseOneOf
 */
export interface CaseOneOf {
    /**
     * 
     * @type {Action}
     * @memberof CaseOneOf
     */
    'case': Action;
    /**
     * 
     * @type {Contract}
     * @memberof CaseOneOf
     */
    'then': Contract;
}
/**
 * 
 * @export
 * @interface CaseOneOf1
 */
export interface CaseOneOf1 {
    /**
     * 
     * @type {Action}
     * @memberof CaseOneOf1
     */
    'case': Action;
    /**
     * 
     * @type {string}
     * @memberof CaseOneOf1
     */
    'merkleized_then': string;
}
/**
 * Refers to a party by role name.
 * @export
 * @interface ChoiceId
 */
export interface ChoiceId {
    /**
     * 
     * @type {string}
     * @memberof ChoiceId
     */
    'choice_name': string;
    /**
     * 
     * @type {Party}
     * @memberof ChoiceId
     */
    'choice_owner': Party;
}
/**
 * Refers to a party by role name.
 * @export
 * @interface ChoiceIdObject
 */
export interface ChoiceIdObject {
    /**
     * 
     * @type {string}
     * @memberof ChoiceIdObject
     */
    'choice_name': string;
    /**
     * 
     * @type {PartyObject}
     * @memberof ChoiceIdObject
     */
    'choice_owner': PartyObject;
}
/**
 * @type Contract
 * Contract terms specified in Marlowe
 * @export
 */
export type Contract = ContractOneOf | ContractOneOf1 | ContractOneOf2 | ContractOneOf3 | ContractOneOf4 | string;

/**
 * 
 * @export
 * @interface ContractHeader
 */
export interface ContractHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof ContractHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof ContractHeader
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractHeader
     */
    'contractId': string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractHeader
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof ContractHeader
     */
    'roleTokenMintingPolicyId': string;
    /**
     * 
     * @type {TxStatus}
     * @memberof ContractHeader
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractHeader
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof ContractHeader
     */
    'version': MarloweVersion;
}


/**
 * @type ContractObject
 * Contract terms specified in Marlowe
 * @export
 */
export type ContractObject = ActionObjectOneOf | ContractObjectOneOf | ContractObjectOneOf1 | ContractObjectOneOf2 | ContractObjectOneOf3 | ContractObjectOneOf4 | string;

/**
 * A payment will be sent from an account to a payee.
 * @export
 * @interface ContractObjectOneOf
 */
export interface ContractObjectOneOf {
    /**
     * 
     * @type {PartyObject}
     * @memberof ContractObjectOneOf
     */
    'from_account': PartyObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ContractObjectOneOf
     */
    'pay': ValueObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf
     */
    'then': ContractObject;
    /**
     * 
     * @type {PayeeObject}
     * @memberof ContractObjectOneOf
     */
    'to': PayeeObject;
    /**
     * 
     * @type {TokenObject}
     * @memberof ContractObjectOneOf
     */
    'token': TokenObject;
}
/**
 * If an observation is true, the first contract applies, otherwise the second contract applies.
 * @export
 * @interface ContractObjectOneOf1
 */
export interface ContractObjectOneOf1 {
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf1
     */
    'else': ContractObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ContractObjectOneOf1
     */
    'if': ObservationObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf1
     */
    'then': ContractObject;
}
/**
 * Wait for an action to be performed and apply the matching contract when it does. Apply the timeout contract if no actions have been performed in the timeout period.
 * @export
 * @interface ContractObjectOneOf2
 */
export interface ContractObjectOneOf2 {
    /**
     * 
     * @type {number}
     * @memberof ContractObjectOneOf2
     */
    'timeout': number;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf2
     */
    'timeout_continuation': ContractObject;
    /**
     * 
     * @type {Array<CaseObject>}
     * @memberof ContractObjectOneOf2
     */
    'when': Array<CaseObject>;
}
/**
 * Bind a value to a name within the scope of a sub-contract.
 * @export
 * @interface ContractObjectOneOf3
 */
export interface ContractObjectOneOf3 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ContractObjectOneOf3
     */
    'be': ValueObject;
    /**
     * 
     * @type {string}
     * @memberof ContractObjectOneOf3
     */
    'let': string;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf3
     */
    'then': ContractObject;
}
/**
 * Check an observation and produce a warning if it is false.
 * @export
 * @interface ContractObjectOneOf4
 */
export interface ContractObjectOneOf4 {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ContractObjectOneOf4
     */
    'assert': ObservationObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf4
     */
    'then': ContractObject;
}
/**
 * A payment will be sent from an account to a payee.
 * @export
 * @interface ContractOneOf
 */
export interface ContractOneOf {
    /**
     * 
     * @type {Party}
     * @memberof ContractOneOf
     */
    'from_account': Party;
    /**
     * 
     * @type {Value}
     * @memberof ContractOneOf
     */
    'pay': Value;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf
     */
    'then': Contract;
    /**
     * 
     * @type {Payee}
     * @memberof ContractOneOf
     */
    'to': Payee;
    /**
     * 
     * @type {Token}
     * @memberof ContractOneOf
     */
    'token': Token;
}
/**
 * If an observation is true, the first contract applies, otherwise the second contract applies.
 * @export
 * @interface ContractOneOf1
 */
export interface ContractOneOf1 {
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf1
     */
    'else': Contract;
    /**
     * 
     * @type {Observation}
     * @memberof ContractOneOf1
     */
    'if': Observation;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf1
     */
    'then': Contract;
}
/**
 * Wait for an action to be performed and apply the matching contract when it does. Apply the timeout contract if no actions have been performed in the timeout period.
 * @export
 * @interface ContractOneOf2
 */
export interface ContractOneOf2 {
    /**
     * 
     * @type {number}
     * @memberof ContractOneOf2
     */
    'timeout': number;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf2
     */
    'timeout_continuation': Contract;
    /**
     * 
     * @type {Array<Case>}
     * @memberof ContractOneOf2
     */
    'when': Array<Case>;
}
/**
 * Bind a value to a name within the scope of a sub-contract.
 * @export
 * @interface ContractOneOf3
 */
export interface ContractOneOf3 {
    /**
     * 
     * @type {Value}
     * @memberof ContractOneOf3
     */
    'be': Value;
    /**
     * 
     * @type {string}
     * @memberof ContractOneOf3
     */
    'let': string;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf3
     */
    'then': Contract;
}
/**
 * Check an observation and produce a warning if it is false.
 * @export
 * @interface ContractOneOf4
 */
export interface ContractOneOf4 {
    /**
     * 
     * @type {Observation}
     * @memberof ContractOneOf4
     */
    'assert': Observation;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf4
     */
    'then': Contract;
}
/**
 * 
 * @export
 * @interface ContractSourceIds
 */
export interface ContractSourceIds {
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractSourceIds
     */
    'results': Array<string>;
}
/**
 * 
 * @export
 * @interface ContractState
 */
export interface ContractState {
    /**
     * 
     * @type {Assets}
     * @memberof ContractState
     */
    'assets': Assets;
    /**
     * 
     * @type {BlockHeader}
     * @memberof ContractState
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof ContractState
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractState
     */
    'contractId': string;
    /**
     * 
     * @type {Contract}
     * @memberof ContractState
     */
    'currentContract'?: Contract;
    /**
     * 
     * @type {Contract}
     * @memberof ContractState
     */
    'initialContract': Contract;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractState
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof ContractState
     */
    'roleTokenMintingPolicyId': string;
    /**
     * 
     * @type {MarloweState}
     * @memberof ContractState
     */
    'state'?: MarloweState;
    /**
     * 
     * @type {TxStatus}
     * @memberof ContractState
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractState
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {TextEnvelope}
     * @memberof ContractState
     */
    'txBody'?: TextEnvelope;
    /**
     * 
     * @type {Array<Payout>}
     * @memberof ContractState
     */
    'unclaimedPayouts': Array<Payout>;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractState
     */
    'utxo'?: string;
    /**
     * 
     * @type {MarloweVersion}
     * @memberof ContractState
     */
    'version': MarloweVersion;
}


/**
 * 
 * @export
 * @interface CreateContractResponse
 */
export interface CreateContractResponse {
    /**
     * 
     * @type {CreateContractResponseLinks}
     * @memberof CreateContractResponse
     */
    'links': CreateContractResponseLinks;
    /**
     * 
     * @type {CreateTxEnvelope}
     * @memberof CreateContractResponse
     */
    'resource': CreateTxEnvelope;
}
/**
 * 
 * @export
 * @interface CreateContractResponseLinks
 */
export interface CreateContractResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof CreateContractResponseLinks
     */
    'contract'?: string;
}
/**
 * The \"type\" property of \"txBody\" must be \"TxBody BabbageEra\" or \"TxBody ConwayEra\"
 * @export
 * @interface CreateTxBodyEnvelope
 */
export interface CreateTxBodyEnvelope {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof CreateTxBodyEnvelope
     */
    'contractId': string;
    /**
     * 
     * @type {Array<SafetyError>}
     * @memberof CreateTxBodyEnvelope
     */
    'safetyErrors'?: Array<SafetyError>;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof CreateTxBodyEnvelope
     */
    'txBody': TextEnvelope;
}
/**
 * The \"type\" property of \"tx\" must be \"Tx BabbageEra\" or \"Tx ConwayEra\"
 * @export
 * @interface CreateTxEnvelope
 */
export interface CreateTxEnvelope {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof CreateTxEnvelope
     */
    'contractId': string;
    /**
     * 
     * @type {Array<SafetyError>}
     * @memberof CreateTxEnvelope
     */
    'safetyErrors'?: Array<SafetyError>;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof CreateTxEnvelope
     */
    'tx': TextEnvelope;
}
/**
 * 
 * @export
 * @interface ExBudget
 */
export interface ExBudget {
    /**
     * 
     * @type {number}
     * @memberof ExBudget
     */
    'exBudgetCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ExBudget
     */
    'exBudgetMemory': number;
}
/**
 * 
 * @export
 * @interface GetContractResponse
 */
export interface GetContractResponse {
    /**
     * 
     * @type {GetContractResponseLinks}
     * @memberof GetContractResponse
     */
    'links': GetContractResponseLinks;
    /**
     * 
     * @type {ContractState}
     * @memberof GetContractResponse
     */
    'resource': ContractState;
}
/**
 * 
 * @export
 * @interface GetContractResponseLinks
 */
export interface GetContractResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof GetContractResponseLinks
     */
    'transactions'?: string;
}
/**
 * 
 * @export
 * @interface GetContractsResponse
 */
export interface GetContractsResponse {
    /**
     * 
     * @type {Array<GetContractsResponseResultsInner>}
     * @memberof GetContractsResponse
     */
    'results': Array<GetContractsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetContractsResponseResultsInner
 */
export interface GetContractsResponseResultsInner {
    /**
     * 
     * @type {GetContractsResponseResultsInnerLinks}
     * @memberof GetContractsResponseResultsInner
     */
    'links': GetContractsResponseResultsInnerLinks;
    /**
     * 
     * @type {ContractHeader}
     * @memberof GetContractsResponseResultsInner
     */
    'resource': ContractHeader;
}
/**
 * 
 * @export
 * @interface GetContractsResponseResultsInnerLinks
 */
export interface GetContractsResponseResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof GetContractsResponseResultsInnerLinks
     */
    'contract'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetContractsResponseResultsInnerLinks
     */
    'transactions'?: string;
}
/**
 * 
 * @export
 * @interface GetPayoutResponse
 */
export interface GetPayoutResponse {
    /**
     * 
     * @type {GetPayoutResponseLinks}
     * @memberof GetPayoutResponse
     */
    'links': GetPayoutResponseLinks;
    /**
     * 
     * @type {PayoutState}
     * @memberof GetPayoutResponse
     */
    'resource': PayoutState;
}
/**
 * 
 * @export
 * @interface GetPayoutResponseLinks
 */
export interface GetPayoutResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof GetPayoutResponseLinks
     */
    'contract'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPayoutResponseLinks
     */
    'transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPayoutResponseLinks
     */
    'withdrawal'?: string;
}
/**
 * 
 * @export
 * @interface GetPayoutsResponse
 */
export interface GetPayoutsResponse {
    /**
     * 
     * @type {Array<GetPayoutsResponseResultsInner>}
     * @memberof GetPayoutsResponse
     */
    'results': Array<GetPayoutsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPayoutsResponseResultsInner
 */
export interface GetPayoutsResponseResultsInner {
    /**
     * 
     * @type {GetPayoutsResponseResultsInnerLinks}
     * @memberof GetPayoutsResponseResultsInner
     */
    'links': GetPayoutsResponseResultsInnerLinks;
    /**
     * 
     * @type {PayoutHeader}
     * @memberof GetPayoutsResponseResultsInner
     */
    'resource': PayoutHeader;
}
/**
 * 
 * @export
 * @interface GetPayoutsResponseResultsInnerLinks
 */
export interface GetPayoutsResponseResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof GetPayoutsResponseResultsInnerLinks
     */
    'payout'?: string;
}
/**
 * 
 * @export
 * @interface GetTransactionResponse
 */
export interface GetTransactionResponse {
    /**
     * 
     * @type {GetTransactionResponseLinks}
     * @memberof GetTransactionResponse
     */
    'links': GetTransactionResponseLinks;
    /**
     * 
     * @type {Tx}
     * @memberof GetTransactionResponse
     */
    'resource': Tx;
}
/**
 * 
 * @export
 * @interface GetTransactionResponseLinks
 */
export interface GetTransactionResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof GetTransactionResponseLinks
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionResponseLinks
     */
    'previous'?: string;
}
/**
 * 
 * @export
 * @interface GetTransactionsResponse
 */
export interface GetTransactionsResponse {
    /**
     * 
     * @type {Array<GetTransactionsResponseResultsInner>}
     * @memberof GetTransactionsResponse
     */
    'results': Array<GetTransactionsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetTransactionsResponseResultsInner
 */
export interface GetTransactionsResponseResultsInner {
    /**
     * 
     * @type {ApplyInputsResponseLinks}
     * @memberof GetTransactionsResponseResultsInner
     */
    'links': ApplyInputsResponseLinks;
    /**
     * 
     * @type {TxHeader}
     * @memberof GetTransactionsResponseResultsInner
     */
    'resource': TxHeader;
}
/**
 * 
 * @export
 * @interface GetWithdrawalsResponse
 */
export interface GetWithdrawalsResponse {
    /**
     * 
     * @type {Array<GetWithdrawalsResponseResultsInner>}
     * @memberof GetWithdrawalsResponse
     */
    'results': Array<GetWithdrawalsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetWithdrawalsResponseResultsInner
 */
export interface GetWithdrawalsResponseResultsInner {
    /**
     * 
     * @type {GetWithdrawalsResponseResultsInnerLinks}
     * @memberof GetWithdrawalsResponseResultsInner
     */
    'links': GetWithdrawalsResponseResultsInnerLinks;
    /**
     * 
     * @type {WithdrawalHeader}
     * @memberof GetWithdrawalsResponseResultsInner
     */
    'resource': WithdrawalHeader;
}
/**
 * 
 * @export
 * @interface GetWithdrawalsResponseResultsInnerLinks
 */
export interface GetWithdrawalsResponseResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof GetWithdrawalsResponseResultsInnerLinks
     */
    'withdrawal'?: string;
}
/**
 * @type Input
 * An input to a Marlowe transaction
 * @export
 */
export type Input = InputOneOf | InputOneOf1 | InputOneOf2 | InputOneOf3 | InputOneOf4 | string;

/**
 * Notify a contract to check a condition and provide the continuation of the contract
 * @export
 * @interface InputOneOf
 */
export interface InputOneOf {
    /**
     * 
     * @type {string}
     * @memberof InputOneOf
     */
    'continuation_hash': string;
    /**
     * 
     * @type {Contract}
     * @memberof InputOneOf
     */
    'merkleized_continuation': Contract;
}
/**
 * Make a choice in a contract and provide the continuation of the contract
 * @export
 * @interface InputOneOf1
 */
export interface InputOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof InputOneOf1
     */
    'continuation_hash': string;
    /**
     * 
     * @type {ChoiceId}
     * @memberof InputOneOf1
     */
    'for_choice_id': ChoiceId;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf1
     */
    'input_that_chooses_num': number;
    /**
     * 
     * @type {Contract}
     * @memberof InputOneOf1
     */
    'merkleized_continuation': Contract;
}
/**
 * Make a choice in a contract
 * @export
 * @interface InputOneOf2
 */
export interface InputOneOf2 {
    /**
     * 
     * @type {ChoiceId}
     * @memberof InputOneOf2
     */
    'for_choice_id': ChoiceId;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf2
     */
    'input_that_chooses_num': number;
}
/**
 * Deposit funds into an account in a contract and provide the continuation of the contract
 * @export
 * @interface InputOneOf3
 */
export interface InputOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof InputOneOf3
     */
    'continuation_hash': string;
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf3
     */
    'input_from_party': Party;
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf3
     */
    'into_account': Party;
    /**
     * 
     * @type {Contract}
     * @memberof InputOneOf3
     */
    'merkleized_continuation': Contract;
    /**
     * 
     * @type {Token}
     * @memberof InputOneOf3
     */
    'of_token': Token;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf3
     */
    'that_deposits': number;
}
/**
 * Deposit funds into an account in a contract
 * @export
 * @interface InputOneOf4
 */
export interface InputOneOf4 {
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf4
     */
    'input_from_party': Party;
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf4
     */
    'into_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof InputOneOf4
     */
    'of_token': Token;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf4
     */
    'that_deposits': number;
}
/**
 * @type IntervalError
 * A Marlowe transaction interval error.
 * @export
 */
export type IntervalError = IntervalErrorOneOf | IntervalErrorOneOf1;

/**
 * Invalid Marlowe transaction interval.
 * @export
 * @interface IntervalErrorOneOf
 */
export interface IntervalErrorOneOf {
    /**
     * 
     * @type {IntervalErrorOneOfInvalidInterval}
     * @memberof IntervalErrorOneOf
     */
    'invalidInterval': IntervalErrorOneOfInvalidInterval;
}
/**
 * Marlowe transaction interval in past.
 * @export
 * @interface IntervalErrorOneOf1
 */
export interface IntervalErrorOneOf1 {
    /**
     * 
     * @type {IntervalErrorOneOf1IntervalInPastError}
     * @memberof IntervalErrorOneOf1
     */
    'intervalInPastError': IntervalErrorOneOf1IntervalInPastError;
}
/**
 * 
 * @export
 * @interface IntervalErrorOneOf1IntervalInPastError
 */
export interface IntervalErrorOneOf1IntervalInPastError {
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOf1IntervalInPastError
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOf1IntervalInPastError
     */
    'minTime': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOf1IntervalInPastError
     */
    'to': number;
}
/**
 * 
 * @export
 * @interface IntervalErrorOneOfInvalidInterval
 */
export interface IntervalErrorOneOfInvalidInterval {
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOfInvalidInterval
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOfInvalidInterval
     */
    'to': number;
}
/**
 * A bundle of labelled Marlowe objects in define-before-use order.
 * @export
 * @interface LabelledObject
 */
export interface LabelledObject {
    /**
     * An arbitrary text identifier for an object in a Marlowe object bundle.
     * @type {string}
     * @memberof LabelledObject
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof LabelledObject
     */
    'type': LabelledObjectTypeEnum;
    /**
     * 
     * @type {LabelledObjectValue}
     * @memberof LabelledObject
     */
    'value': LabelledObjectValue;
}

export const LabelledObjectTypeEnum = {
    Value: 'value',
    Observation: 'observation',
    Contract: 'contract',
    Party: 'party',
    Token: 'token',
    Action: 'action'
} as const;

export type LabelledObjectTypeEnum = typeof LabelledObjectTypeEnum[keyof typeof LabelledObjectTypeEnum];

/**
 * @type LabelledObjectValue
 * @export
 */
export type LabelledObjectValue = ActionObject | ContractObject | ObservationObject | PartyObject | TokenObject | ValueObject;

/**
 * The on-chain state of a Marlowe contract.
 * @export
 * @interface MarloweState
 */
export interface MarloweState {
    /**
     * 
     * @type {Array<Array<MarloweStateAccountsInnerInner>>}
     * @memberof MarloweState
     */
    'accounts': Array<Array<MarloweStateAccountsInnerInner>>;
    /**
     * 
     * @type {Array<Array<MarloweStateBoundValuesInnerInner>>}
     * @memberof MarloweState
     */
    'boundValues': Array<Array<MarloweStateBoundValuesInnerInner>>;
    /**
     * 
     * @type {Array<Array<MarloweStateChoicesInnerInner>>}
     * @memberof MarloweState
     */
    'choices': Array<Array<MarloweStateChoicesInnerInner>>;
    /**
     * 
     * @type {number}
     * @memberof MarloweState
     */
    'minTime': number;
}
/**
 * @type MarloweStateAccountsInnerInner
 * @export
 */
export type MarloweStateAccountsInnerInner = Array<MarloweStateAccountsInnerInnerOneOfInner> | number;

/**
 * @type MarloweStateAccountsInnerInnerOneOfInner
 * @export
 */
export type MarloweStateAccountsInnerInnerOneOfInner = Party | Token;

/**
 * @type MarloweStateBoundValuesInnerInner
 * @export
 */
export type MarloweStateBoundValuesInnerInner = number | string;

/**
 * @type MarloweStateChoicesInnerInner
 * @export
 */
export type MarloweStateChoicesInnerInner = ChoiceId | number;

/**
 * A version of the Marlowe language.
 * @export
 * @enum {string}
 */

export const MarloweVersion = {
    V1: 'v1'
} as const;

export type MarloweVersion = typeof MarloweVersion[keyof typeof MarloweVersion];


/**
 * Describe the reducibility (Can be Reduced ?) and the applicability (Can Inputs be Applied ?) for a given contract.
 * @export
 * @interface Next
 */
export interface Next {
    /**
     * 
     * @type {ApplicableInputs}
     * @memberof Next
     */
    'applicable_inputs': ApplicableInputs;
    /**
     * Indicates if a given contract can be reduced (apply []) or not.
     * @type {boolean}
     * @memberof Next
     */
    'can_reduce': boolean;
}
/**
 * @type Observation
 * A time-varying expression that evaluates to an integer
 * @export
 */
export type Observation = ObservationOneOf | ObservationOneOf1 | ObservationOneOf2 | ObservationOneOf3 | ObservationOneOf4 | ObservationOneOf5 | ObservationOneOf6 | ObservationOneOf7 | ObservationOneOf8 | boolean;

/**
 * @type ObservationObject
 * A time-varying expression that evaluates to an integer
 * @export
 */
export type ObservationObject = ActionObjectOneOf | ObservationObjectOneOf | ObservationObjectOneOf1 | ObservationObjectOneOf2 | ObservationObjectOneOf3 | ObservationObjectOneOf4 | ObservationObjectOneOf5 | ObservationObjectOneOf6 | ObservationObjectOneOf7 | ObservationObjectOneOf8 | boolean;

/**
 * 
 * @export
 * @interface ObservationObjectOneOf
 */
export interface ObservationObjectOneOf {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf
     */
    'and': ObservationObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf
     */
    'both': ObservationObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf1
 */
export interface ObservationObjectOneOf1 {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf1
     */
    'either': ObservationObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf1
     */
    'or': ObservationObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf2
 */
export interface ObservationObjectOneOf2 {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf2
     */
    'not': ObservationObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf3
 */
export interface ObservationObjectOneOf3 {
    /**
     * 
     * @type {ChoiceIdObject}
     * @memberof ObservationObjectOneOf3
     */
    'chose_something_for': ChoiceIdObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf4
 */
export interface ObservationObjectOneOf4 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf4
     */
    'ge_than': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf4
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf5
 */
export interface ObservationObjectOneOf5 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf5
     */
    'gt': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf5
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf6
 */
export interface ObservationObjectOneOf6 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf6
     */
    'lt': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf6
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf7
 */
export interface ObservationObjectOneOf7 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf7
     */
    'le_than': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf7
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf8
 */
export interface ObservationObjectOneOf8 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf8
     */
    'equal_to': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf8
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationOneOf
 */
export interface ObservationOneOf {
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf
     */
    'and': Observation;
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf
     */
    'both': Observation;
}
/**
 * 
 * @export
 * @interface ObservationOneOf1
 */
export interface ObservationOneOf1 {
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf1
     */
    'either': Observation;
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf1
     */
    'or': Observation;
}
/**
 * 
 * @export
 * @interface ObservationOneOf2
 */
export interface ObservationOneOf2 {
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf2
     */
    'not': Observation;
}
/**
 * 
 * @export
 * @interface ObservationOneOf3
 */
export interface ObservationOneOf3 {
    /**
     * 
     * @type {ChoiceId}
     * @memberof ObservationOneOf3
     */
    'chose_something_for': ChoiceId;
}
/**
 * 
 * @export
 * @interface ObservationOneOf4
 */
export interface ObservationOneOf4 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf4
     */
    'ge_than': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf4
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf5
 */
export interface ObservationOneOf5 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf5
     */
    'gt': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf5
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf6
 */
export interface ObservationOneOf6 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf6
     */
    'lt': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf6
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf7
 */
export interface ObservationOneOf7 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf7
     */
    'le_than': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf7
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf8
 */
export interface ObservationOneOf8 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf8
     */
    'equal_to': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf8
     */
    'value': Value;
}
/**
 * @type Party
 * A participant in a contract
 * @export
 */
export type Party = PartyOneOf | PartyOneOf1;

/**
 * @type PartyObject
 * A participant in a contract
 * @export
 */
export type PartyObject = ActionObjectOneOf | PartyOneOf | PartyOneOf1;

/**
 * Refers to a party by role name.
 * @export
 * @interface PartyOneOf
 */
export interface PartyOneOf {
    /**
     * 
     * @type {string}
     * @memberof PartyOneOf
     */
    'role_token': string;
}
/**
 * Refers to a party by Cardano address.
 * @export
 * @interface PartyOneOf1
 */
export interface PartyOneOf1 {
    /**
     * A cardano address, in Bech32 format
     * @type {string}
     * @memberof PartyOneOf1
     */
    'address': string;
}
/**
 * @type Payee
 * A recipient of a payment
 * @export
 */
export type Payee = PayeeOneOf | PayeeOneOf1;

/**
 * @type PayeeObject
 * A recipient of a payment
 * @export
 */
export type PayeeObject = PayeeObjectOneOf | PayeeObjectOneOf1;

/**
 * Pays funds into a party\'s account in the contract.
 * @export
 * @interface PayeeObjectOneOf
 */
export interface PayeeObjectOneOf {
    /**
     * 
     * @type {PartyObject}
     * @memberof PayeeObjectOneOf
     */
    'account': PartyObject;
}
/**
 * Pays funds to a party.
 * @export
 * @interface PayeeObjectOneOf1
 */
export interface PayeeObjectOneOf1 {
    /**
     * 
     * @type {PartyObject}
     * @memberof PayeeObjectOneOf1
     */
    'party': PartyObject;
}
/**
 * Pays funds into a party\'s account in the contract.
 * @export
 * @interface PayeeOneOf
 */
export interface PayeeOneOf {
    /**
     * 
     * @type {Party}
     * @memberof PayeeOneOf
     */
    'account': Party;
}
/**
 * Pays funds to a party.
 * @export
 * @interface PayeeOneOf1
 */
export interface PayeeOneOf1 {
    /**
     * 
     * @type {Party}
     * @memberof PayeeOneOf1
     */
    'party': Party;
}
/**
 * A Marlowe payment.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'amount': number;
    /**
     * 
     * @type {Party}
     * @memberof Payment
     */
    'payment_from': Party;
    /**
     * 
     * @type {Payee}
     * @memberof Payment
     */
    'to': Payee;
    /**
     * 
     * @type {Token}
     * @memberof Payment
     */
    'token': Token;
}
/**
 * 
 * @export
 * @interface Payout
 */
export interface Payout {
    /**
     * 
     * @type {Assets}
     * @memberof Payout
     */
    'assets': Assets;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Payout
     */
    'payoutId': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface PayoutHeader
 */
export interface PayoutHeader {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutHeader
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutHeader
     */
    'payoutId': string;
    /**
     * 
     * @type {AssetId}
     * @memberof PayoutHeader
     */
    'role': AssetId;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutHeader
     */
    'status': PayoutStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof PayoutHeader
     */
    'withdrawalId'?: string;
}


/**
 * 
 * @export
 * @interface PayoutState
 */
export interface PayoutState {
    /**
     * 
     * @type {Assets}
     * @memberof PayoutState
     */
    'assets': Assets;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutState
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutState
     */
    'payoutId': string;
    /**
     * A cardano address, in Bech32 format
     * @type {string}
     * @memberof PayoutState
     */
    'payoutValidatorAddress': string;
    /**
     * 
     * @type {AssetId}
     * @memberof PayoutState
     */
    'role': AssetId;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutState
     */
    'status': PayoutStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof PayoutState
     */
    'withdrawalId'?: string;
}


/**
 * The status of a payout. Either it is available to be withdrawn, or it has already been withdrawn.
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    Available: 'available',
    Withdrawn: 'withdrawn'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * A Plutus address.
 * @export
 * @interface PlutusAddress
 */
export interface PlutusAddress {
    /**
     * 
     * @type {PlutusCredential}
     * @memberof PlutusAddress
     */
    'addressCredential': PlutusCredential;
    /**
     * 
     * @type {PlutusStakingCredential}
     * @memberof PlutusAddress
     */
    'addressStakingCredential'?: PlutusStakingCredential;
}
/**
 * @type PlutusCredential
 * A Plutus credential.
 * @export
 */
export type PlutusCredential = PlutusCredentialOneOf | PlutusCredentialOneOf1;

/**
 * A Plutus public key credential.
 * @export
 * @interface PlutusCredentialOneOf
 */
export interface PlutusCredentialOneOf {
    /**
     * 
     * @type {string}
     * @memberof PlutusCredentialOneOf
     */
    'pubKeyCredential': string;
}
/**
 * A Plutus script credential.
 * @export
 * @interface PlutusCredentialOneOf1
 */
export interface PlutusCredentialOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof PlutusCredentialOneOf1
     */
    'scriptCredential': string;
}
/**
 * @type PlutusStakingCredential
 * A Plutus staking credential.
 * @export
 */
export type PlutusStakingCredential = PlutusStakingCredentialOneOf | PlutusStakingCredentialOneOf1;

/**
 * A Plutus staking hash.
 * @export
 * @interface PlutusStakingCredentialOneOf
 */
export interface PlutusStakingCredentialOneOf {
    /**
     * 
     * @type {PlutusCredential}
     * @memberof PlutusStakingCredentialOneOf
     */
    'stakingHash': PlutusCredential;
}
/**
 * A Plutus staking pointer.
 * @export
 * @interface PlutusStakingCredentialOneOf1
 */
export interface PlutusStakingCredentialOneOf1 {
    /**
     * 
     * @type {Array<number>}
     * @memberof PlutusStakingCredentialOneOf1
     */
    'stakingHash': Array<number>;
}
/**
 * 
 * @export
 * @interface PostContractSourceResponse
 */
export interface PostContractSourceResponse {
    /**
     * The hex-encoded identifier of a Marlowe contract source
     * @type {string}
     * @memberof PostContractSourceResponse
     */
    'contractSourceId': string;
    /**
     * 
     * @type {{ [key: string]: string | undefined; }}
     * @memberof PostContractSourceResponse
     */
    'intermediateIds': { [key: string]: string | undefined; };
}
/**
 * 
 * @export
 * @interface PostContractsRequest
 */
export interface PostContractsRequest {
    /**
     * 
     * @type {PostContractsRequestContract}
     * @memberof PostContractsRequest
     */
    'contract': PostContractsRequestContract;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostContractsRequest
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {number}
     * @memberof PostContractsRequest
     */
    'minUTxODeposit'?: number;
    /**
     * 
     * @type {RolesConfig}
     * @memberof PostContractsRequest
     */
    'roles'?: RolesConfig;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostContractsRequest
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof PostContractsRequest
     */
    'version': MarloweVersion;
}


/**
 * @type PostContractsRequestContract
 * @export
 */
export type PostContractsRequestContract = Contract | string;

/**
 * 
 * @export
 * @interface PostTransactionsRequest
 */
export interface PostTransactionsRequest {
    /**
     * 
     * @type {Array<Input>}
     * @memberof PostTransactionsRequest
     */
    'inputs': Array<Input>;
    /**
     * 
     * @type {string}
     * @memberof PostTransactionsRequest
     */
    'invalidBefore'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostTransactionsRequest
     */
    'invalidHereafter'?: string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostTransactionsRequest
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostTransactionsRequest
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof PostTransactionsRequest
     */
    'version': MarloweVersion;
}


/**
 * 
 * @export
 * @interface PostWithdrawalsRequest
 */
export interface PostWithdrawalsRequest {
    /**
     * 
     * @type {Set<string>}
     * @memberof PostWithdrawalsRequest
     */
    'payouts': Set<string>;
}
/**
 * @type RoleTokenConfig
 * @export
 */
export type RoleTokenConfig = RoleTokenConfigOneOf | RoleTokenConfigOneOf1 | string;

/**
 * 
 * @export
 * @interface RoleTokenConfigOneOf
 */
export interface RoleTokenConfigOneOf {
    /**
     * A cardano address, in Bech32 format
     * @type {string}
     * @memberof RoleTokenConfigOneOf
     */
    'address': string;
    /**
     * 
     * @type {TokenMetadata}
     * @memberof RoleTokenConfigOneOf
     */
    'metadata': TokenMetadata;
}
/**
 * 
 * @export
 * @interface RoleTokenConfigOneOf1
 */
export interface RoleTokenConfigOneOf1 {
    /**
     * 
     * @type {TokenMetadata}
     * @memberof RoleTokenConfigOneOf1
     */
    'metadata'?: TokenMetadata;
    /**
     * The type of script receiving the role token.
     * @type {string}
     * @memberof RoleTokenConfigOneOf1
     */
    'script': RoleTokenConfigOneOf1ScriptEnum;
}

export const RoleTokenConfigOneOf1ScriptEnum = {
    ThreadRole: 'ThreadRole',
    OpenRole: 'OpenRole'
} as const;

export type RoleTokenConfigOneOf1ScriptEnum = typeof RoleTokenConfigOneOf1ScriptEnum[keyof typeof RoleTokenConfigOneOf1ScriptEnum];

/**
 * @type RolesConfig
 * @export
 */
export type RolesConfig = string | { [key: string]: RoleTokenConfig | undefined; };

/**
 * Information about the safety of a Marlowe contract and its state.
 * @export
 * @interface SafetyError
 */
export interface SafetyError {
    /**
     * 
     * @type {Party}
     * @memberof SafetyError
     */
    'account-id'?: Party;
    /**
     * 
     * @type {PlutusAddress}
     * @memberof SafetyError
     */
    'address'?: PlutusAddress;
    /**
     * 
     * @type {number}
     * @memberof SafetyError
     */
    'bytes'?: number;
    /**
     * 
     * @type {ChoiceId}
     * @memberof SafetyError
     */
    'choice-id'?: ChoiceId;
    /**
     * 
     * @type {ExBudget}
     * @memberof SafetyError
     */
    'cost'?: ExBudget;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'currency-symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'error': string;
    /**
     * 
     * @type {boolean}
     * @memberof SafetyError
     */
    'fatal': boolean;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'role-name'?: string;
    /**
     * 
     * @type {Token}
     * @memberof SafetyError
     */
    'token'?: Token;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'token-name'?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof SafetyError
     */
    'transaction'?: Transaction;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'value-id'?: string;
    /**
     * 
     * @type {TransactionWarning}
     * @memberof SafetyError
     */
    'warning'?: TransactionWarning;
}
/**
 * 
 * @export
 * @interface TextEnvelope
 */
export interface TextEnvelope {
    /**
     * 
     * @type {string}
     * @memberof TextEnvelope
     */
    'cborHex': string;
    /**
     * 
     * @type {string}
     * @memberof TextEnvelope
     */
    'description': string;
    /**
     * What type of data is encoded in the CBOR Hex. Valid values include \"Tx <era>\", \"TxBody <era>\", and \"ShelleyTxWitness <era>\" where <era> is one of \"BabbageEra\", \"ConwayEra\".
     * @type {string}
     * @memberof TextEnvelope
     */
    'type': string;
}
/**
 * A token with a currency symbol (minting policy ID) and token name.
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'currency_symbol': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_name': string;
}
/**
 * Metadata for an NFT, as described by https://cips.cardano.org/cips/cip25/
 * @export
 * @interface TokenMetadata
 */
export interface TokenMetadata {
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {Array<TokenMetadataFile>}
     * @memberof TokenMetadata
     */
    'files'?: Array<TokenMetadataFile>;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'mediaType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TokenMetadataFile
 */
export interface TokenMetadataFile {
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'mediaType': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'src': string;
}
/**
 * @type TokenObject
 * A token with a currency symbol (minting policy ID) and token name.
 * @export
 */
export type TokenObject = ActionObjectOneOf | Token;

/**
 * Information about a Marlowe transaction.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {Contract}
     * @memberof Transaction
     */
    'contract': Contract;
    /**
     * 
     * @type {TransactionInput}
     * @memberof Transaction
     */
    'input': TransactionInput;
    /**
     * 
     * @type {TransactionOutput}
     * @memberof Transaction
     */
    'output': TransactionOutput;
    /**
     * 
     * @type {MarloweState}
     * @memberof Transaction
     */
    'state': MarloweState;
}
/**
 * @type TransactionError
 * A Marlowe transaction error.
 * @export
 */
export type TransactionError = TransactionErrorOneOf | string;

/**
 * An invalid time interval.
 * @export
 * @interface TransactionErrorOneOf
 */
export interface TransactionErrorOneOf {
    /**
     * 
     * @type {IntervalError}
     * @memberof TransactionErrorOneOf
     */
    'context': IntervalError;
    /**
     * 
     * @type {string}
     * @memberof TransactionErrorOneOf
     */
    'error': TransactionErrorOneOfErrorEnum;
}

export const TransactionErrorOneOfErrorEnum = {
    TeIntervalError: 'TEIntervalError'
} as const;

export type TransactionErrorOneOfErrorEnum = typeof TransactionErrorOneOfErrorEnum[keyof typeof TransactionErrorOneOfErrorEnum];

/**
 * Marlowe transaction input.
 * @export
 * @interface TransactionInput
 */
export interface TransactionInput {
    /**
     * 
     * @type {Array<Input>}
     * @memberof TransactionInput
     */
    'tx_inputs': Array<Input>;
    /**
     * 
     * @type {TransactionInputTxInterval}
     * @memberof TransactionInput
     */
    'tx_interval': TransactionInputTxInterval;
}
/**
 * Time interval.
 * @export
 * @interface TransactionInputTxInterval
 */
export interface TransactionInputTxInterval {
    /**
     * 
     * @type {number}
     * @memberof TransactionInputTxInterval
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionInputTxInterval
     */
    'to': number;
}
/**
 * @type TransactionOutput
 * Marlowe transaction output.
 * @export
 */
export type TransactionOutput = TransactionOutputOneOf | TransactionOutputOneOf1;

/**
 * Marlowe transaction output information.
 * @export
 * @interface TransactionOutputOneOf
 */
export interface TransactionOutputOneOf {
    /**
     * 
     * @type {Contract}
     * @memberof TransactionOutputOneOf
     */
    'contract': Contract;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof TransactionOutputOneOf
     */
    'payments': Array<Payment>;
    /**
     * 
     * @type {MarloweState}
     * @memberof TransactionOutputOneOf
     */
    'state': MarloweState;
    /**
     * 
     * @type {Array<TransactionWarning>}
     * @memberof TransactionOutputOneOf
     */
    'warnings': Array<TransactionWarning>;
}
/**
 * Marlowe transaction error.
 * @export
 * @interface TransactionOutputOneOf1
 */
export interface TransactionOutputOneOf1 {
    /**
     * 
     * @type {TransactionError}
     * @memberof TransactionOutputOneOf1
     */
    'transaction_error': TransactionError;
}
/**
 * @type TransactionWarning
 * A transaction semantics warning.
 * @export
 */
export type TransactionWarning = TransactionWarningOneOf | TransactionWarningOneOf1 | TransactionWarningOneOf2 | TransactionWarningOneOf3 | string;

/**
 * A warning for a non-positive deposit.
 * @export
 * @interface TransactionWarningOneOf
 */
export interface TransactionWarningOneOf {
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf
     */
    'asked_to_deposit': number;
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf
     */
    'in_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof TransactionWarningOneOf
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf
     */
    'party': Party;
}
/**
 * A warning for a non-positive payment.
 * @export
 * @interface TransactionWarningOneOf1
 */
export interface TransactionWarningOneOf1 {
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf1
     */
    'account': Party;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf1
     */
    'asked_to_pay': number;
    /**
     * 
     * @type {Token}
     * @memberof TransactionWarningOneOf1
     */
    'of_token': Token;
    /**
     * 
     * @type {Payee}
     * @memberof TransactionWarningOneOf1
     */
    'to_payee': Payee;
}
/**
 * A warning for partial payment.
 * @export
 * @interface TransactionWarningOneOf2
 */
export interface TransactionWarningOneOf2 {
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf2
     */
    'account': Party;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf2
     */
    'asked_to_pay': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf2
     */
    'but_only_paid': number;
    /**
     * 
     * @type {Token}
     * @memberof TransactionWarningOneOf2
     */
    'of_token': Token;
    /**
     * 
     * @type {Payee}
     * @memberof TransactionWarningOneOf2
     */
    'to_payee': Payee;
}
/**
 * A variable-name shadowing warning.
 * @export
 * @interface TransactionWarningOneOf3
 */
export interface TransactionWarningOneOf3 {
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf3
     */
    'had_value': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf3
     */
    'is_now_assigned': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionWarningOneOf3
     */
    'value_id': string;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {Assets}
     * @memberof Tx
     */
    'assets': Assets;
    /**
     * 
     * @type {BlockHeader}
     * @memberof Tx
     */
    'block'?: BlockHeader;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Tx
     */
    'consumingTx'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'inputUtxo': string;
    /**
     * 
     * @type {Array<Input>}
     * @memberof Tx
     */
    'inputs': Array<Input>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'invalidBefore': string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'invalidHereafter': string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof Tx
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {Contract}
     * @memberof Tx
     */
    'outputContract'?: Contract;
    /**
     * 
     * @type {MarloweState}
     * @memberof Tx
     */
    'outputState'?: MarloweState;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'outputUtxo'?: string;
    /**
     * 
     * @type {Array<Payout>}
     * @memberof Tx
     */
    'payouts': Array<Payout>;
    /**
     * 
     * @type {TxStatus}
     * @memberof Tx
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof Tx
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Tx
     */
    'transactionId': string;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof Tx
     */
    'txBody'?: TextEnvelope;
}


/**
 * 
 * @export
 * @interface TxHeader
 */
export interface TxHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof TxHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof TxHeader
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof TxHeader
     */
    'contractId': string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof TxHeader
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {TxStatus}
     * @memberof TxHeader
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof TxHeader
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof TxHeader
     */
    'transactionId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof TxHeader
     */
    'utxo'?: string;
}


/**
 * The status of a transaction on the local node.
 * @export
 * @enum {string}
 */

export const TxStatus = {
    Unsigned: 'unsigned',
    Submitted: 'submitted',
    Confirmed: 'confirmed'
} as const;

export type TxStatus = typeof TxStatus[keyof typeof TxStatus];


/**
 * @type Value
 * A time-varying expression that evaluates to a boolean
 * @export
 */
export type Value = ValueOneOf | ValueOneOf1 | ValueOneOf2 | ValueOneOf3 | ValueOneOf4 | ValueOneOf5 | ValueOneOf6 | ValueOneOf7 | ValueOneOf8 | number | string;

/**
 * @type ValueObject
 * A time-varying expression that evaluates to a boolean
 * @export
 */
export type ValueObject = ActionObjectOneOf | ValueObjectOneOf | ValueObjectOneOf1 | ValueObjectOneOf2 | ValueObjectOneOf3 | ValueObjectOneOf4 | ValueObjectOneOf5 | ValueObjectOneOf6 | ValueObjectOneOf7 | ValueOneOf7 | number | string;

/**
 * 
 * @export
 * @interface ValueObjectOneOf
 */
export interface ValueObjectOneOf {
    /**
     * 
     * @type {TokenObject}
     * @memberof ValueObjectOneOf
     */
    'amount_of_token': TokenObject;
    /**
     * 
     * @type {PartyObject}
     * @memberof ValueObjectOneOf
     */
    'in_account': PartyObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf1
 */
export interface ValueObjectOneOf1 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf1
     */
    'negate': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf2
 */
export interface ValueObjectOneOf2 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf2
     */
    'add': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf2
     */
    'and': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf3
 */
export interface ValueObjectOneOf3 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf3
     */
    'minus': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf3
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf4
 */
export interface ValueObjectOneOf4 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf4
     */
    'multiply': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf4
     */
    'times': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf5
 */
export interface ValueObjectOneOf5 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf5
     */
    'by': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf5
     */
    'divide': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf6
 */
export interface ValueObjectOneOf6 {
    /**
     * 
     * @type {ChoiceIdObject}
     * @memberof ValueObjectOneOf6
     */
    'value_of_choice': ChoiceIdObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf7
 */
export interface ValueObjectOneOf7 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf7
     */
    'else': ValueObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ValueObjectOneOf7
     */
    'if': ObservationObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf7
     */
    'then': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueOneOf
 */
export interface ValueOneOf {
    /**
     * 
     * @type {Token}
     * @memberof ValueOneOf
     */
    'amount_of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof ValueOneOf
     */
    'in_account': Party;
}
/**
 * 
 * @export
 * @interface ValueOneOf1
 */
export interface ValueOneOf1 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf1
     */
    'negate': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf2
 */
export interface ValueOneOf2 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf2
     */
    'add': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf2
     */
    'and': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf3
 */
export interface ValueOneOf3 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf3
     */
    'minus': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf3
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf4
 */
export interface ValueOneOf4 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf4
     */
    'multiply': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf4
     */
    'times': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf5
 */
export interface ValueOneOf5 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf5
     */
    'by': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf5
     */
    'divide': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf6
 */
export interface ValueOneOf6 {
    /**
     * 
     * @type {ChoiceId}
     * @memberof ValueOneOf6
     */
    'value_of_choice': ChoiceId;
}
/**
 * 
 * @export
 * @interface ValueOneOf7
 */
export interface ValueOneOf7 {
    /**
     * 
     * @type {string}
     * @memberof ValueOneOf7
     */
    'use_value': string;
}
/**
 * 
 * @export
 * @interface ValueOneOf8
 */
export interface ValueOneOf8 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf8
     */
    'else': Value;
    /**
     * 
     * @type {Observation}
     * @memberof ValueOneOf8
     */
    'if': Observation;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf8
     */
    'then': Value;
}
/**
 * 
 * @export
 * @interface WithdrawPayoutsResponse
 */
export interface WithdrawPayoutsResponse {
    /**
     * 
     * @type {GetWithdrawalsResponseResultsInnerLinks}
     * @memberof WithdrawPayoutsResponse
     */
    'links': GetWithdrawalsResponseResultsInnerLinks;
    /**
     * 
     * @type {WithdrawTxEnvelope}
     * @memberof WithdrawPayoutsResponse
     */
    'resource': WithdrawTxEnvelope;
}
/**
 * The \"type\" property of \"txBody\" must be \"TxBody BabbageEra\" or \"TxBody ConwayEra\"
 * @export
 * @interface WithdrawTxBodyEnvelope
 */
export interface WithdrawTxBodyEnvelope {
    /**
     * 
     * @type {TextEnvelope}
     * @memberof WithdrawTxBodyEnvelope
     */
    'txBody': TextEnvelope;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof WithdrawTxBodyEnvelope
     */
    'withdrawalId': string;
}
/**
 * The \"type\" property of \"tx\" must be \"Tx BabbageEra\" or \"Tx ConwayEra\"
 * @export
 * @interface WithdrawTxEnvelope
 */
export interface WithdrawTxEnvelope {
    /**
     * 
     * @type {TextEnvelope}
     * @memberof WithdrawTxEnvelope
     */
    'tx': TextEnvelope;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof WithdrawTxEnvelope
     */
    'withdrawalId': string;
}
/**
 * 
 * @export
 * @interface Withdrawal
 */
export interface Withdrawal {
    /**
     * 
     * @type {BlockHeader}
     * @memberof Withdrawal
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {Set<PayoutHeader>}
     * @memberof Withdrawal
     */
    'payouts': Set<PayoutHeader>;
    /**
     * 
     * @type {TxStatus}
     * @memberof Withdrawal
     */
    'status': TxStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Withdrawal
     */
    'withdrawalId': string;
}


/**
 * 
 * @export
 * @interface WithdrawalHeader
 */
export interface WithdrawalHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof WithdrawalHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {TxStatus}
     * @memberof WithdrawalHeader
     */
    'status': TxStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof WithdrawalHeader
     */
    'withdrawalId': string;
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
         * @summary Apply inputs to contract
         * @param {string} contractId 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostTransactionsRequest} [postTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyInputsToContract: async (contractId: string, xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postTransactionsRequest?: PostTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('applyInputsToContract', 'contractId', contractId)
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('applyInputsToContract', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/contracts/{contractId}/transactions`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
         * @summary Create a new contract
         * @param {string} xChangeAddress 
         * @param {string} [xStakeAddress] Where to send staking rewards for the Marlowe script outputs of this contract.
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostContractsRequest} [postContractsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (xChangeAddress: string, xStakeAddress?: string, xAddress?: string, xCollateralUTxO?: string, postContractsRequest?: PostContractsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('createContract', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xStakeAddress != null) {
                localVarHeaderParameter['X-Stake-Address'] = String(xStakeAddress);
            }

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postContractsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
         * @summary Upload contract sources
         * @param {string} main The label of the top-level contract object in the bundle(s).
         * @param {Array<LabelledObject>} [labelledObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractSources: async (main: string, labelledObject?: Array<LabelledObject>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'main' is not null or undefined
            assertParamExists('createContractSources', 'main', main)
            const localVarPath = `/contracts/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (main !== undefined) {
                localVarQueryParameter['main'] = main;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labelledObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract by ID
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractById: async (contractId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractById', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
         * @summary Get adjacent contract source IDs by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceAdjacency: async (contractSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('getContractSourceAdjacency', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}/adjacency`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract source by ID
         * @param {string} contractSourceId 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceById: async (contractSourceId: string, expand?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('getContractSourceById', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
         * @summary Get contract source closure by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceClosure: async (contractSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('getContractSourceClosure', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}/closure`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract transaction by ID
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTransactionById: async (contractId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractTransactionById', 'contractId', contractId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getContractTransactionById', 'transactionId', transactionId)
            const localVarPath = `/contracts/{contractId}/transactions/{transactionId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
         * @summary Get contracts
         * @param {Array<string>} [roleCurrency] 
         * @param {Array<string>} [tag] 
         * @param {Array<string>} [partyAddress] 
         * @param {Array<string>} [partyRole] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts: async (roleCurrency?: Array<string>, tag?: Array<string>, partyAddress?: Array<string>, partyRole?: Array<string>, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleCurrency) {
                localVarQueryParameter['roleCurrency'] = roleCurrency;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (partyAddress) {
                localVarQueryParameter['partyAddress'] = partyAddress;
            }

            if (partyRole) {
                localVarQueryParameter['partyRole'] = partyRole;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get inputs which could be performed on a contract withing a time range by the requested parties.
         * @summary Get next contract steps
         * @param {string} contractId 
         * @param {string} validityStart The beginning of the validity range.
         * @param {string} validityEnd The end of the validity range.
         * @param {Array<string>} [party] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextStepsForContract: async (contractId: string, validityStart: string, validityEnd: string, party?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getNextStepsForContract', 'contractId', contractId)
            // verify required parameter 'validityStart' is not null or undefined
            assertParamExists('getNextStepsForContract', 'validityStart', validityStart)
            // verify required parameter 'validityEnd' is not null or undefined
            assertParamExists('getNextStepsForContract', 'validityEnd', validityEnd)
            const localVarPath = `/contracts/{contractId}/next`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (validityStart !== undefined) {
                localVarQueryParameter['validityStart'] = validityStart;
            }

            if (validityEnd !== undefined) {
                localVarQueryParameter['validityEnd'] = validityEnd;
            }

            if (party) {
                localVarQueryParameter['party'] = party;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payout by ID
         * @param {string} payoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById: async (payoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('getPayoutById', 'payoutId', payoutId)
            const localVarPath = `/payouts/{payoutId}`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
         * @summary Get role payouts
         * @param {Array<string>} [contractId] 
         * @param {Array<string>} [roleToken] 
         * @param {GetPayoutsStatusEnum} [status] Whether to include available or withdrawn payouts in the results.
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayouts: async (contractId?: Array<string>, roleToken?: Array<string>, status?: GetPayoutsStatusEnum, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (roleToken) {
                localVarQueryParameter['roleToken'] = roleToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
         * @summary Get transactions for contract
         * @param {string} contractId 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsForContract: async (contractId: string, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getTransactionsForContract', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}/transactions`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get withdrawal by ID
         * @param {string} withdrawalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalById: async (withdrawalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('getWithdrawalById', 'withdrawalId', withdrawalId)
            const localVarPath = `/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
         * @summary Get withdrawals
         * @param {Array<string>} [roleCurrency] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals: async (roleCurrency?: Array<string>, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleCurrency) {
                localVarQueryParameter['roleCurrency'] = roleCurrency;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the server is running and ready to respond to requests.
         * @summary Test server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
         * @summary Submit contract to chain
         * @param {string} contractId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContract: async (contractId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('submitContract', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
         * @summary Submit contract input application
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContractTransaction: async (contractId: string, transactionId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('submitContractTransaction', 'contractId', contractId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('submitContractTransaction', 'transactionId', transactionId)
            const localVarPath = `/contracts/{contractId}/transactions/{transactionId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
         * @summary Submit payout withdrawal
         * @param {string} withdrawalId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWithdrawal: async (withdrawalId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('submitWithdrawal', 'withdrawalId', withdrawalId)
            const localVarPath = `/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
         * @summary Withdraw payouts
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostWithdrawalsRequest} [postWithdrawalsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawPayouts: async (xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postWithdrawalsRequest?: PostWithdrawalsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('withdrawPayouts', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postWithdrawalsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
         * @summary Apply inputs to contract
         * @param {string} contractId 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostTransactionsRequest} [postTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyInputsToContract(contractId: string, xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postTransactionsRequest?: PostTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplyInputsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyInputsToContract(contractId, xChangeAddress, xAddress, xCollateralUTxO, postTransactionsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.applyInputsToContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
         * @summary Create a new contract
         * @param {string} xChangeAddress 
         * @param {string} [xStakeAddress] Where to send staking rewards for the Marlowe script outputs of this contract.
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostContractsRequest} [postContractsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(xChangeAddress: string, xStakeAddress?: string, xAddress?: string, xCollateralUTxO?: string, postContractsRequest?: PostContractsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(xChangeAddress, xStakeAddress, xAddress, xCollateralUTxO, postContractsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.createContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
         * @summary Upload contract sources
         * @param {string} main The label of the top-level contract object in the bundle(s).
         * @param {Array<LabelledObject>} [labelledObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractSources(main: string, labelledObject?: Array<LabelledObject>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContractSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractSources(main, labelledObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.createContractSources']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get contract by ID
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractById(contractId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractById(contractId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
         * @summary Get adjacent contract source IDs by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractSourceAdjacency(contractSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSourceIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractSourceAdjacency(contractSourceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractSourceAdjacency']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get contract source by ID
         * @param {string} contractSourceId 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractSourceById(contractSourceId: string, expand?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractSourceById(contractSourceId, expand, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractSourceById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
         * @summary Get contract source closure by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractSourceClosure(contractSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSourceIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractSourceClosure(contractSourceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractSourceClosure']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get contract transaction by ID
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractTransactionById(contractId: string, transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractTransactionById(contractId, transactionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractTransactionById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
         * @summary Get contracts
         * @param {Array<string>} [roleCurrency] 
         * @param {Array<string>} [tag] 
         * @param {Array<string>} [partyAddress] 
         * @param {Array<string>} [partyRole] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContracts(roleCurrency?: Array<string>, tag?: Array<string>, partyAddress?: Array<string>, partyRole?: Array<string>, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts(roleCurrency, tag, partyAddress, partyRole, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContracts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get inputs which could be performed on a contract withing a time range by the requested parties.
         * @summary Get next contract steps
         * @param {string} contractId 
         * @param {string} validityStart The beginning of the validity range.
         * @param {string} validityEnd The end of the validity range.
         * @param {Array<string>} [party] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextStepsForContract(contractId: string, validityStart: string, validityEnd: string, party?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Next>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextStepsForContract(contractId, validityStart, validityEnd, party, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getNextStepsForContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get payout by ID
         * @param {string} payoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayoutById(payoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutById(payoutId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getPayoutById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
         * @summary Get role payouts
         * @param {Array<string>} [contractId] 
         * @param {Array<string>} [roleToken] 
         * @param {GetPayoutsStatusEnum} [status] Whether to include available or withdrawn payouts in the results.
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayouts(contractId?: Array<string>, roleToken?: Array<string>, status?: GetPayoutsStatusEnum, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayoutsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayouts(contractId, roleToken, status, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getPayouts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
         * @summary Get transactions for contract
         * @param {string} contractId 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsForContract(contractId: string, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsForContract(contractId, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getTransactionsForContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get withdrawal by ID
         * @param {string} withdrawalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawalById(withdrawalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Withdrawal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawalById(withdrawalId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getWithdrawalById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
         * @summary Get withdrawals
         * @param {Array<string>} [roleCurrency] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawals(roleCurrency?: Array<string>, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWithdrawalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawals(roleCurrency, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getWithdrawals']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if the server is running and ready to respond to requests.
         * @summary Test server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheck(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.healthcheck']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
         * @summary Submit contract to chain
         * @param {string} contractId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitContract(contractId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitContract(contractId, textEnvelope, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.submitContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
         * @summary Submit contract input application
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitContractTransaction(contractId: string, transactionId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitContractTransaction(contractId, transactionId, textEnvelope, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.submitContractTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
         * @summary Submit payout withdrawal
         * @param {string} withdrawalId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitWithdrawal(withdrawalId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitWithdrawal(withdrawalId, textEnvelope, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.submitWithdrawal']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
         * @summary Withdraw payouts
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostWithdrawalsRequest} [postWithdrawalsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawPayouts(xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postWithdrawalsRequest?: PostWithdrawalsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawPayoutsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawPayouts(xChangeAddress, xAddress, xCollateralUTxO, postWithdrawalsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.withdrawPayouts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
         * @summary Apply inputs to contract
         * @param {DefaultApiApplyInputsToContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyInputsToContract(requestParameters: DefaultApiApplyInputsToContractRequest, options?: AxiosRequestConfig): AxiosPromise<ApplyInputsResponse> {
            return localVarFp.applyInputsToContract(requestParameters.contractId, requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
         * @summary Create a new contract
         * @param {DefaultApiCreateContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract(requestParameters: DefaultApiCreateContractRequest, options?: AxiosRequestConfig): AxiosPromise<CreateContractResponse> {
            return localVarFp.createContract(requestParameters.xChangeAddress, requestParameters.xStakeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postContractsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
         * @summary Upload contract sources
         * @param {DefaultApiCreateContractSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractSources(requestParameters: DefaultApiCreateContractSourcesRequest, options?: AxiosRequestConfig): AxiosPromise<PostContractSourceResponse> {
            return localVarFp.createContractSources(requestParameters.main, requestParameters.labelledObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract by ID
         * @param {DefaultApiGetContractByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractById(requestParameters: DefaultApiGetContractByIdRequest, options?: AxiosRequestConfig): AxiosPromise<GetContractResponse> {
            return localVarFp.getContractById(requestParameters.contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
         * @summary Get adjacent contract source IDs by ID
         * @param {DefaultApiGetContractSourceAdjacencyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceAdjacency(requestParameters: DefaultApiGetContractSourceAdjacencyRequest, options?: AxiosRequestConfig): AxiosPromise<ContractSourceIds> {
            return localVarFp.getContractSourceAdjacency(requestParameters.contractSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract source by ID
         * @param {DefaultApiGetContractSourceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceById(requestParameters: DefaultApiGetContractSourceByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.getContractSourceById(requestParameters.contractSourceId, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
         * @summary Get contract source closure by ID
         * @param {DefaultApiGetContractSourceClosureRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceClosure(requestParameters: DefaultApiGetContractSourceClosureRequest, options?: AxiosRequestConfig): AxiosPromise<ContractSourceIds> {
            return localVarFp.getContractSourceClosure(requestParameters.contractSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract transaction by ID
         * @param {DefaultApiGetContractTransactionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTransactionById(requestParameters: DefaultApiGetContractTransactionByIdRequest, options?: AxiosRequestConfig): AxiosPromise<GetTransactionResponse> {
            return localVarFp.getContractTransactionById(requestParameters.contractId, requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
         * @summary Get contracts
         * @param {DefaultApiGetContractsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts(requestParameters: DefaultApiGetContractsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetContractsResponse> {
            return localVarFp.getContracts(requestParameters.roleCurrency, requestParameters.tag, requestParameters.partyAddress, requestParameters.partyRole, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Get inputs which could be performed on a contract withing a time range by the requested parties.
         * @summary Get next contract steps
         * @param {DefaultApiGetNextStepsForContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextStepsForContract(requestParameters: DefaultApiGetNextStepsForContractRequest, options?: AxiosRequestConfig): AxiosPromise<Next> {
            return localVarFp.getNextStepsForContract(requestParameters.contractId, requestParameters.validityStart, requestParameters.validityEnd, requestParameters.party, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payout by ID
         * @param {DefaultApiGetPayoutByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById(requestParameters: DefaultApiGetPayoutByIdRequest, options?: AxiosRequestConfig): AxiosPromise<GetPayoutResponse> {
            return localVarFp.getPayoutById(requestParameters.payoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
         * @summary Get role payouts
         * @param {DefaultApiGetPayoutsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayouts(requestParameters: DefaultApiGetPayoutsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetPayoutsResponse> {
            return localVarFp.getPayouts(requestParameters.contractId, requestParameters.roleToken, requestParameters.status, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
         * @summary Get transactions for contract
         * @param {DefaultApiGetTransactionsForContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsForContract(requestParameters: DefaultApiGetTransactionsForContractRequest, options?: AxiosRequestConfig): AxiosPromise<GetTransactionsResponse> {
            return localVarFp.getTransactionsForContract(requestParameters.contractId, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get withdrawal by ID
         * @param {DefaultApiGetWithdrawalByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalById(requestParameters: DefaultApiGetWithdrawalByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Withdrawal> {
            return localVarFp.getWithdrawalById(requestParameters.withdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
         * @summary Get withdrawals
         * @param {DefaultApiGetWithdrawalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals(requestParameters: DefaultApiGetWithdrawalsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetWithdrawalsResponse> {
            return localVarFp.getWithdrawals(requestParameters.roleCurrency, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the server is running and ready to respond to requests.
         * @summary Test server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthcheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
         * @summary Submit contract to chain
         * @param {DefaultApiSubmitContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContract(requestParameters: DefaultApiSubmitContractRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitContract(requestParameters.contractId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
         * @summary Submit contract input application
         * @param {DefaultApiSubmitContractTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContractTransaction(requestParameters: DefaultApiSubmitContractTransactionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitContractTransaction(requestParameters.contractId, requestParameters.transactionId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
         * @summary Submit payout withdrawal
         * @param {DefaultApiSubmitWithdrawalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWithdrawal(requestParameters: DefaultApiSubmitWithdrawalRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitWithdrawal(requestParameters.withdrawalId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
         * @summary Withdraw payouts
         * @param {DefaultApiWithdrawPayoutsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawPayouts(requestParameters: DefaultApiWithdrawPayoutsRequest, options?: AxiosRequestConfig): AxiosPromise<WithdrawPayoutsResponse> {
            return localVarFp.withdrawPayouts(requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postWithdrawalsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applyInputsToContract operation in DefaultApi.
 * @export
 * @interface DefaultApiApplyInputsToContractRequest
 */
export interface DefaultApiApplyInputsToContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly xChangeAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostTransactionsRequest}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly postTransactionsRequest?: PostTransactionsRequest
}

/**
 * Request parameters for createContract operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateContractRequest
 */
export interface DefaultApiCreateContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xChangeAddress: string

    /**
     * Where to send staking rewards for the Marlowe script outputs of this contract.
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xStakeAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostContractsRequest}
     * @memberof DefaultApiCreateContract
     */
    readonly postContractsRequest?: PostContractsRequest
}

/**
 * Request parameters for createContractSources operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateContractSourcesRequest
 */
export interface DefaultApiCreateContractSourcesRequest {
    /**
     * The label of the top-level contract object in the bundle(s).
     * @type {string}
     * @memberof DefaultApiCreateContractSources
     */
    readonly main: string

    /**
     * 
     * @type {Array<LabelledObject>}
     * @memberof DefaultApiCreateContractSources
     */
    readonly labelledObject?: Array<LabelledObject>
}

/**
 * Request parameters for getContractById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractByIdRequest
 */
export interface DefaultApiGetContractByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractById
     */
    readonly contractId: string
}

/**
 * Request parameters for getContractSourceAdjacency operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractSourceAdjacencyRequest
 */
export interface DefaultApiGetContractSourceAdjacencyRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractSourceAdjacency
     */
    readonly contractSourceId: string
}

/**
 * Request parameters for getContractSourceById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractSourceByIdRequest
 */
export interface DefaultApiGetContractSourceByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractSourceById
     */
    readonly contractSourceId: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiGetContractSourceById
     */
    readonly expand?: boolean
}

/**
 * Request parameters for getContractSourceClosure operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractSourceClosureRequest
 */
export interface DefaultApiGetContractSourceClosureRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractSourceClosure
     */
    readonly contractSourceId: string
}

/**
 * Request parameters for getContractTransactionById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractTransactionByIdRequest
 */
export interface DefaultApiGetContractTransactionByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractTransactionById
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractTransactionById
     */
    readonly transactionId: string
}

/**
 * Request parameters for getContracts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractsRequest
 */
export interface DefaultApiGetContractsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly roleCurrency?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly tag?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly partyAddress?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly partyRole?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContracts
     */
    readonly range?: string
}

/**
 * Request parameters for getNextStepsForContract operation in DefaultApi.
 * @export
 * @interface DefaultApiGetNextStepsForContractRequest
 */
export interface DefaultApiGetNextStepsForContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly contractId: string

    /**
     * The beginning of the validity range.
     * @type {string}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly validityStart: string

    /**
     * The end of the validity range.
     * @type {string}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly validityEnd: string

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly party?: Array<string>
}

/**
 * Request parameters for getPayoutById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPayoutByIdRequest
 */
export interface DefaultApiGetPayoutByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetPayoutById
     */
    readonly payoutId: string
}

/**
 * Request parameters for getPayouts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPayoutsRequest
 */
export interface DefaultApiGetPayoutsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetPayouts
     */
    readonly contractId?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetPayouts
     */
    readonly roleToken?: Array<string>

    /**
     * Whether to include available or withdrawn payouts in the results.
     * @type {'available' | 'withdrawn'}
     * @memberof DefaultApiGetPayouts
     */
    readonly status?: GetPayoutsStatusEnum

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetPayouts
     */
    readonly range?: string
}

/**
 * Request parameters for getTransactionsForContract operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTransactionsForContractRequest
 */
export interface DefaultApiGetTransactionsForContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetTransactionsForContract
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetTransactionsForContract
     */
    readonly range?: string
}

/**
 * Request parameters for getWithdrawalById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetWithdrawalByIdRequest
 */
export interface DefaultApiGetWithdrawalByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetWithdrawalById
     */
    readonly withdrawalId: string
}

/**
 * Request parameters for getWithdrawals operation in DefaultApi.
 * @export
 * @interface DefaultApiGetWithdrawalsRequest
 */
export interface DefaultApiGetWithdrawalsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetWithdrawals
     */
    readonly roleCurrency?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetWithdrawals
     */
    readonly range?: string
}

/**
 * Request parameters for submitContract operation in DefaultApi.
 * @export
 * @interface DefaultApiSubmitContractRequest
 */
export interface DefaultApiSubmitContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitContract
     */
    readonly contractId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiSubmitContract
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for submitContractTransaction operation in DefaultApi.
 * @export
 * @interface DefaultApiSubmitContractTransactionRequest
 */
export interface DefaultApiSubmitContractTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitContractTransaction
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitContractTransaction
     */
    readonly transactionId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiSubmitContractTransaction
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for submitWithdrawal operation in DefaultApi.
 * @export
 * @interface DefaultApiSubmitWithdrawalRequest
 */
export interface DefaultApiSubmitWithdrawalRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitWithdrawal
     */
    readonly withdrawalId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiSubmitWithdrawal
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for withdrawPayouts operation in DefaultApi.
 * @export
 * @interface DefaultApiWithdrawPayoutsRequest
 */
export interface DefaultApiWithdrawPayoutsRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly xChangeAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostWithdrawalsRequest}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly postWithdrawalsRequest?: PostWithdrawalsRequest
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
     * @summary Apply inputs to contract
     * @param {DefaultApiApplyInputsToContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public applyInputsToContract(requestParameters: DefaultApiApplyInputsToContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).applyInputsToContract(requestParameters.contractId, requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
     * @summary Create a new contract
     * @param {DefaultApiCreateContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createContract(requestParameters: DefaultApiCreateContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createContract(requestParameters.xChangeAddress, requestParameters.xStakeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postContractsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
     * @summary Upload contract sources
     * @param {DefaultApiCreateContractSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createContractSources(requestParameters: DefaultApiCreateContractSourcesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createContractSources(requestParameters.main, requestParameters.labelledObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract by ID
     * @param {DefaultApiGetContractByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractById(requestParameters: DefaultApiGetContractByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractById(requestParameters.contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
     * @summary Get adjacent contract source IDs by ID
     * @param {DefaultApiGetContractSourceAdjacencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractSourceAdjacency(requestParameters: DefaultApiGetContractSourceAdjacencyRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractSourceAdjacency(requestParameters.contractSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract source by ID
     * @param {DefaultApiGetContractSourceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractSourceById(requestParameters: DefaultApiGetContractSourceByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractSourceById(requestParameters.contractSourceId, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
     * @summary Get contract source closure by ID
     * @param {DefaultApiGetContractSourceClosureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractSourceClosure(requestParameters: DefaultApiGetContractSourceClosureRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractSourceClosure(requestParameters.contractSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract transaction by ID
     * @param {DefaultApiGetContractTransactionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractTransactionById(requestParameters: DefaultApiGetContractTransactionByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractTransactionById(requestParameters.contractId, requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
     * @summary Get contracts
     * @param {DefaultApiGetContractsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContracts(requestParameters: DefaultApiGetContractsRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContracts(requestParameters.roleCurrency, requestParameters.tag, requestParameters.partyAddress, requestParameters.partyRole, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get inputs which could be performed on a contract withing a time range by the requested parties.
     * @summary Get next contract steps
     * @param {DefaultApiGetNextStepsForContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNextStepsForContract(requestParameters: DefaultApiGetNextStepsForContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNextStepsForContract(requestParameters.contractId, requestParameters.validityStart, requestParameters.validityEnd, requestParameters.party, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payout by ID
     * @param {DefaultApiGetPayoutByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPayoutById(requestParameters: DefaultApiGetPayoutByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPayoutById(requestParameters.payoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
     * @summary Get role payouts
     * @param {DefaultApiGetPayoutsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPayouts(requestParameters: DefaultApiGetPayoutsRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPayouts(requestParameters.contractId, requestParameters.roleToken, requestParameters.status, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
     * @summary Get transactions for contract
     * @param {DefaultApiGetTransactionsForContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTransactionsForContract(requestParameters: DefaultApiGetTransactionsForContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTransactionsForContract(requestParameters.contractId, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get withdrawal by ID
     * @param {DefaultApiGetWithdrawalByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWithdrawalById(requestParameters: DefaultApiGetWithdrawalByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWithdrawalById(requestParameters.withdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
     * @summary Get withdrawals
     * @param {DefaultApiGetWithdrawalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWithdrawals(requestParameters: DefaultApiGetWithdrawalsRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWithdrawals(requestParameters.roleCurrency, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the server is running and ready to respond to requests.
     * @summary Test server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthcheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthcheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
     * @summary Submit contract to chain
     * @param {DefaultApiSubmitContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitContract(requestParameters: DefaultApiSubmitContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitContract(requestParameters.contractId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
     * @summary Submit contract input application
     * @param {DefaultApiSubmitContractTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitContractTransaction(requestParameters: DefaultApiSubmitContractTransactionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitContractTransaction(requestParameters.contractId, requestParameters.transactionId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
     * @summary Submit payout withdrawal
     * @param {DefaultApiSubmitWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitWithdrawal(requestParameters: DefaultApiSubmitWithdrawalRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitWithdrawal(requestParameters.withdrawalId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
     * @summary Withdraw payouts
     * @param {DefaultApiWithdrawPayoutsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public withdrawPayouts(requestParameters: DefaultApiWithdrawPayoutsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).withdrawPayouts(requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postWithdrawalsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetPayoutsStatusEnum = {
    Available: 'available',
    Withdrawn: 'withdrawn'
} as const;
export type GetPayoutsStatusEnum = typeof GetPayoutsStatusEnum[keyof typeof GetPayoutsStatusEnum];


