/* tslint:disable */
/* eslint-disable */
/**
 * 
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * @type Action
 * A contract which becomes active when an action occurs.
 * @export
 */
export type Action = ActionOneOf | ActionOneOf1 | ActionOneOf2;

/**
 * @type ActionObject
 * A contract which becomes active when an action occurs.
 * @export
 */
export type ActionObject = ActionOneOf | ActionOneOf1 | ActionOneOf2 | ValueObjectOneOf8;

/**
 * 
 * @export
 * @interface ActionOneOf
 */
export interface ActionOneOf {
    /**
     * 
     * @type {Value}
     * @memberof ActionOneOf
     */
    'deposits': Value;
    /**
     * 
     * @type {Party}
     * @memberof ActionOneOf
     */
    'into_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof ActionOneOf
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof ActionOneOf
     */
    'party': Party;
}
/**
 * 
 * @export
 * @interface ActionOneOf1
 */
export interface ActionOneOf1 {
    /**
     * 
     * @type {Array<Bound>}
     * @memberof ActionOneOf1
     */
    'choose_between': Array<Bound>;
    /**
     * 
     * @type {ChoiceId}
     * @memberof ActionOneOf1
     */
    'for_choice': ChoiceId;
}
/**
 * 
 * @export
 * @interface ActionOneOf2
 */
export interface ActionOneOf2 {
    /**
     * 
     * @type {Observation}
     * @memberof ActionOneOf2
     */
    'notify_if': Observation;
}
/**
 * Applicable Inputs for a given contract
 * @export
 * @interface ApplicableInputs
 */
export interface ApplicableInputs {
    /**
     * 
     * @type {Array<CanChoose>}
     * @memberof ApplicableInputs
     */
    'choices': Array<CanChoose>;
    /**
     * 
     * @type {Array<CanDeposit>}
     * @memberof ApplicableInputs
     */
    'deposits': Array<CanDeposit>;
    /**
     * 
     * @type {CanNotify}
     * @memberof ApplicableInputs
     */
    'notify'?: CanNotify;
}
/**
 * 
 * @export
 * @interface ApplyInputsTxEnvelope
 */
export interface ApplyInputsTxEnvelope {
    /**
     * 
     * @type {TextEnvelope}
     * @memberof ApplyInputsTxEnvelope
     */
    'tx': TextEnvelope;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof ApplyInputsTxEnvelope
     */
    'withdrawalId': string;
}
/**
 * 
 * @export
 * @interface AssetId
 */
export interface AssetId {
    /**
     * 
     * @type {string}
     * @memberof AssetId
     */
    'assetName': string;
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof AssetId
     */
    'policyId': string;
}
/**
 * 
 * @export
 * @interface Assets
 */
export interface Assets {
    /**
     * 
     * @type {number}
     * @memberof Assets
     */
    'lovelace': number;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number | undefined; } | undefined; }}
     * @memberof Assets
     */
    'tokens': { [key: string]: { [key: string]: number | undefined; } | undefined; };
}
/**
 * 
 * @export
 * @interface BlockHeader
 */
export interface BlockHeader {
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    'blockHeaderHash': string;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    'blockNo': number;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    'slotNo': number;
}
/**
 * An inclusive range of values for a choice.
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * 
     * @type {number}
     * @memberof Bound
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof Bound
     */
    'to': number;
}
/**
 * Choice Inputs that can be applied for a given contract
 * @export
 * @interface CanChoose
 */
export interface CanChoose {
    /**
     * 
     * @type {Array<Bound>}
     * @memberof CanChoose
     */
    'can_choose_between': Array<Bound>;
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanChoose
     */
    'case_index': number;
    /**
     * 
     * @type {ChoiceId}
     * @memberof CanChoose
     */
    'for_choice': ChoiceId;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanChoose
     */
    'is_merkleized_continuation': boolean;
}
/**
 * Deposit Input that can be applied for a given contract
 * @export
 * @interface CanDeposit
 */
export interface CanDeposit {
    /**
     * 
     * @type {number}
     * @memberof CanDeposit
     */
    'can_deposit': number;
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanDeposit
     */
    'case_index': number;
    /**
     * 
     * @type {Party}
     * @memberof CanDeposit
     */
    'into_account': Party;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanDeposit
     */
    'is_merkleized_continuation': boolean;
    /**
     * 
     * @type {Token}
     * @memberof CanDeposit
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof CanDeposit
     */
    'party': Party;
}
/**
 * Notify Input tha can be applied for a given contract
 * @export
 * @interface CanNotify
 */
export interface CanNotify {
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanNotify
     */
    'case_index': number;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanNotify
     */
    'is_merkleized_continuation': boolean;
}
/**
 * @type Case
 * A contract which becomes active when an action occurs.
 * @export
 */
export type Case = CaseOneOf | CaseOneOf1;

/**
 * @type CaseObject
 * A contract which becomes active when an action occurs.
 * @export
 */
export type CaseObject = CaseObjectOneOf | CaseObjectOneOf1;

/**
 * 
 * @export
 * @interface CaseObjectOneOf
 */
export interface CaseObjectOneOf {
    /**
     * 
     * @type {ActionObject}
     * @memberof CaseObjectOneOf
     */
    'case': ActionObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof CaseObjectOneOf
     */
    'then': ContractObject;
}
/**
 * 
 * @export
 * @interface CaseObjectOneOf1
 */
export interface CaseObjectOneOf1 {
    /**
     * 
     * @type {ActionObject}
     * @memberof CaseObjectOneOf1
     */
    'case': ActionObject;
    /**
     * 
     * @type {string}
     * @memberof CaseObjectOneOf1
     */
    'merkleized_then': string;
}
/**
 * 
 * @export
 * @interface CaseOneOf
 */
export interface CaseOneOf {
    /**
     * 
     * @type {Action}
     * @memberof CaseOneOf
     */
    'case': Action;
    /**
     * 
     * @type {Contract}
     * @memberof CaseOneOf
     */
    'then': Contract;
}
/**
 * 
 * @export
 * @interface CaseOneOf1
 */
export interface CaseOneOf1 {
    /**
     * 
     * @type {Action}
     * @memberof CaseOneOf1
     */
    'case': Action;
    /**
     * 
     * @type {string}
     * @memberof CaseOneOf1
     */
    'merkleized_then': string;
}
/**
 * Refers to a party by role name.
 * @export
 * @interface ChoiceId
 */
export interface ChoiceId {
    /**
     * 
     * @type {string}
     * @memberof ChoiceId
     */
    'choice_name': string;
    /**
     * 
     * @type {Party}
     * @memberof ChoiceId
     */
    'choice_owner': Party;
}
/**
 * Refers to a party by role name.
 * @export
 * @interface ChoiceIdObject
 */
export interface ChoiceIdObject {
    /**
     * 
     * @type {string}
     * @memberof ChoiceIdObject
     */
    'choice_name': string;
    /**
     * 
     * @type {PartyObject}
     * @memberof ChoiceIdObject
     */
    'choice_owner': PartyObject;
}
/**
 * @type Contract
 * Contract terms specified in Marlowe
 * @export
 */
export type Contract = ContractOneOf | ContractOneOf1 | ContractOneOf2 | ContractOneOf3 | ContractOneOf4 | string;

/**
 * 
 * @export
 * @interface ContractHeader
 */
export interface ContractHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof ContractHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof ContractHeader
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractHeader
     */
    'contractId': string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractHeader
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof ContractHeader
     */
    'roleTokenMintingPolicyId': string;
    /**
     * 
     * @type {TxStatus}
     * @memberof ContractHeader
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractHeader
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof ContractHeader
     */
    'version': MarloweVersion;
}


/**
 * @type ContractObject
 * Contract terms specified in Marlowe
 * @export
 */
export type ContractObject = ContractObjectOneOf | ContractObjectOneOf1 | ContractObjectOneOf2 | ContractObjectOneOf3 | ContractObjectOneOf4 | ValueObjectOneOf8 | string;

/**
 * A payment will be sent from an account to a payee.
 * @export
 * @interface ContractObjectOneOf
 */
export interface ContractObjectOneOf {
    /**
     * 
     * @type {PartyObject}
     * @memberof ContractObjectOneOf
     */
    'from_account': PartyObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ContractObjectOneOf
     */
    'pay': ValueObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf
     */
    'then': ContractObject;
    /**
     * 
     * @type {PayeeObject}
     * @memberof ContractObjectOneOf
     */
    'to': PayeeObject;
    /**
     * 
     * @type {TokenObject}
     * @memberof ContractObjectOneOf
     */
    'token': TokenObject;
}
/**
 * If an observation is true, the first contract applies, otherwise the second contract applies.
 * @export
 * @interface ContractObjectOneOf1
 */
export interface ContractObjectOneOf1 {
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf1
     */
    'else': ContractObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ContractObjectOneOf1
     */
    'if': ObservationObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf1
     */
    'then': ContractObject;
}
/**
 * Wait for an action to be performed and apply the matching contract when it does. Apply the timeout contract if no actions have been performed in the timeout period.
 * @export
 * @interface ContractObjectOneOf2
 */
export interface ContractObjectOneOf2 {
    /**
     * 
     * @type {number}
     * @memberof ContractObjectOneOf2
     */
    'timeout': number;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf2
     */
    'timeout_continuation': ContractObject;
    /**
     * 
     * @type {Array<CaseObject>}
     * @memberof ContractObjectOneOf2
     */
    'when': Array<CaseObject>;
}
/**
 * Bind a value to a name within the scope of a sub-contract.
 * @export
 * @interface ContractObjectOneOf3
 */
export interface ContractObjectOneOf3 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ContractObjectOneOf3
     */
    'be': ValueObject;
    /**
     * 
     * @type {string}
     * @memberof ContractObjectOneOf3
     */
    'let': string;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf3
     */
    'then': ContractObject;
}
/**
 * Check an observation and produce a warning if it is false.
 * @export
 * @interface ContractObjectOneOf4
 */
export interface ContractObjectOneOf4 {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ContractObjectOneOf4
     */
    'assert': ObservationObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof ContractObjectOneOf4
     */
    'then': ContractObject;
}
/**
 * A payment will be sent from an account to a payee.
 * @export
 * @interface ContractOneOf
 */
export interface ContractOneOf {
    /**
     * 
     * @type {Party}
     * @memberof ContractOneOf
     */
    'from_account': Party;
    /**
     * 
     * @type {Value}
     * @memberof ContractOneOf
     */
    'pay': Value;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf
     */
    'then': Contract;
    /**
     * 
     * @type {Payee}
     * @memberof ContractOneOf
     */
    'to': Payee;
    /**
     * 
     * @type {Token}
     * @memberof ContractOneOf
     */
    'token': Token;
}
/**
 * If an observation is true, the first contract applies, otherwise the second contract applies.
 * @export
 * @interface ContractOneOf1
 */
export interface ContractOneOf1 {
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf1
     */
    'else': Contract;
    /**
     * 
     * @type {Observation}
     * @memberof ContractOneOf1
     */
    'if': Observation;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf1
     */
    'then': Contract;
}
/**
 * Wait for an action to be performed and apply the matching contract when it does. Apply the timeout contract if no actions have been performed in the timeout period.
 * @export
 * @interface ContractOneOf2
 */
export interface ContractOneOf2 {
    /**
     * 
     * @type {number}
     * @memberof ContractOneOf2
     */
    'timeout': number;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf2
     */
    'timeout_continuation': Contract;
    /**
     * 
     * @type {Array<Case>}
     * @memberof ContractOneOf2
     */
    'when': Array<Case>;
}
/**
 * Bind a value to a name within the scope of a sub-contract.
 * @export
 * @interface ContractOneOf3
 */
export interface ContractOneOf3 {
    /**
     * 
     * @type {Value}
     * @memberof ContractOneOf3
     */
    'be': Value;
    /**
     * 
     * @type {string}
     * @memberof ContractOneOf3
     */
    'let': string;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf3
     */
    'then': Contract;
}
/**
 * Check an observation and produce a warning if it is false.
 * @export
 * @interface ContractOneOf4
 */
export interface ContractOneOf4 {
    /**
     * 
     * @type {Observation}
     * @memberof ContractOneOf4
     */
    'assert': Observation;
    /**
     * 
     * @type {Contract}
     * @memberof ContractOneOf4
     */
    'then': Contract;
}
/**
 * 
 * @export
 * @interface ContractState
 */
export interface ContractState {
    /**
     * 
     * @type {Assets}
     * @memberof ContractState
     */
    'assets': Assets;
    /**
     * 
     * @type {BlockHeader}
     * @memberof ContractState
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof ContractState
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractState
     */
    'contractId': string;
    /**
     * 
     * @type {Contract}
     * @memberof ContractState
     */
    'currentContract'?: Contract;
    /**
     * 
     * @type {Contract}
     * @memberof ContractState
     */
    'initialContract': Contract;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractState
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof ContractState
     */
    'roleTokenMintingPolicyId': string;
    /**
     * 
     * @type {MarloweState}
     * @memberof ContractState
     */
    'state'?: MarloweState;
    /**
     * 
     * @type {TxStatus}
     * @memberof ContractState
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof ContractState
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {TextEnvelope}
     * @memberof ContractState
     */
    'txBody'?: TextEnvelope;
    /**
     * 
     * @type {Array<Payout>}
     * @memberof ContractState
     */
    'unclaimedPayouts': Array<Payout>;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractState
     */
    'utxo'?: string;
    /**
     * 
     * @type {MarloweVersion}
     * @memberof ContractState
     */
    'version': MarloweVersion;
}


/**
 * 
 * @export
 * @interface ContractsContractIdGet200Response
 */
export interface ContractsContractIdGet200Response {
    /**
     * 
     * @type {ContractsContractIdGet200ResponseLinks}
     * @memberof ContractsContractIdGet200Response
     */
    'links': ContractsContractIdGet200ResponseLinks;
    /**
     * 
     * @type {ContractState}
     * @memberof ContractsContractIdGet200Response
     */
    'resource': ContractState;
}
/**
 * 
 * @export
 * @interface ContractsContractIdGet200ResponseLinks
 */
export interface ContractsContractIdGet200ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof ContractsContractIdGet200ResponseLinks
     */
    'transactions'?: string;
}
/**
 * 
 * @export
 * @interface ContractsContractIdTransactionsPost201Response
 */
export interface ContractsContractIdTransactionsPost201Response {
    /**
     * 
     * @type {ContractsContractIdTransactionsPost201ResponseLinks}
     * @memberof ContractsContractIdTransactionsPost201Response
     */
    'links': ContractsContractIdTransactionsPost201ResponseLinks;
    /**
     * 
     * @type {ApplyInputsTxEnvelope}
     * @memberof ContractsContractIdTransactionsPost201Response
     */
    'resource': ApplyInputsTxEnvelope;
}
/**
 * 
 * @export
 * @interface ContractsContractIdTransactionsPost201ResponseLinks
 */
export interface ContractsContractIdTransactionsPost201ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof ContractsContractIdTransactionsPost201ResponseLinks
     */
    'transaction'?: string;
}
/**
 * 
 * @export
 * @interface ContractsContractIdTransactionsTransactionIdGet200Response
 */
export interface ContractsContractIdTransactionsTransactionIdGet200Response {
    /**
     * 
     * @type {ContractsContractIdTransactionsTransactionIdGet200ResponseLinks}
     * @memberof ContractsContractIdTransactionsTransactionIdGet200Response
     */
    'links': ContractsContractIdTransactionsTransactionIdGet200ResponseLinks;
    /**
     * 
     * @type {Tx}
     * @memberof ContractsContractIdTransactionsTransactionIdGet200Response
     */
    'resource': Tx;
}
/**
 * 
 * @export
 * @interface ContractsContractIdTransactionsTransactionIdGet200ResponseLinks
 */
export interface ContractsContractIdTransactionsTransactionIdGet200ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof ContractsContractIdTransactionsTransactionIdGet200ResponseLinks
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof ContractsContractIdTransactionsTransactionIdGet200ResponseLinks
     */
    'previous'?: string;
}
/**
 * 
 * @export
 * @interface ContractsPost201Response
 */
export interface ContractsPost201Response {
    /**
     * 
     * @type {ContractsPost201ResponseLinks}
     * @memberof ContractsPost201Response
     */
    'links': ContractsPost201ResponseLinks;
    /**
     * 
     * @type {ApplyInputsTxEnvelope}
     * @memberof ContractsPost201Response
     */
    'resource': ApplyInputsTxEnvelope;
}
/**
 * 
 * @export
 * @interface ContractsPost201ResponseLinks
 */
export interface ContractsPost201ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof ContractsPost201ResponseLinks
     */
    'contract'?: string;
}
/**
 * 
 * @export
 * @interface ExBudget
 */
export interface ExBudget {
    /**
     * 
     * @type {number}
     * @memberof ExBudget
     */
    'exBudgetCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ExBudget
     */
    'exBudgetMemory': number;
}
/**
 * @type Input
 * An input to a Marlowe transaction
 * @export
 */
export type Input = InputOneOf | InputOneOf1 | InputOneOf2 | InputOneOf3 | InputOneOf4 | string;

/**
 * Notify a contract to check a condition and provide the continuation of the contract
 * @export
 * @interface InputOneOf
 */
export interface InputOneOf {
    /**
     * 
     * @type {string}
     * @memberof InputOneOf
     */
    'continuation_hash': string;
    /**
     * 
     * @type {Contract}
     * @memberof InputOneOf
     */
    'merkleized_continuation': Contract;
}
/**
 * Make a choice in a contract and provide the continuation of the contract
 * @export
 * @interface InputOneOf1
 */
export interface InputOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof InputOneOf1
     */
    'continuation_hash': string;
    /**
     * 
     * @type {ChoiceId}
     * @memberof InputOneOf1
     */
    'for_choice_id': ChoiceId;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf1
     */
    'input_that_chooses_num': number;
    /**
     * 
     * @type {Contract}
     * @memberof InputOneOf1
     */
    'merkleized_continuation': Contract;
}
/**
 * Make a choice in a contract
 * @export
 * @interface InputOneOf2
 */
export interface InputOneOf2 {
    /**
     * 
     * @type {ChoiceId}
     * @memberof InputOneOf2
     */
    'for_choice_id': ChoiceId;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf2
     */
    'input_that_chooses_num': number;
}
/**
 * Deposit funds into an account in a contract and provide the continuation of the contract
 * @export
 * @interface InputOneOf3
 */
export interface InputOneOf3 {
    /**
     * 
     * @type {string}
     * @memberof InputOneOf3
     */
    'continuation_hash': string;
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf3
     */
    'input_from_party': Party;
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf3
     */
    'into_account': Party;
    /**
     * 
     * @type {Contract}
     * @memberof InputOneOf3
     */
    'merkleized_continuation': Contract;
    /**
     * 
     * @type {Token}
     * @memberof InputOneOf3
     */
    'of_token': Token;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf3
     */
    'that_deposits': number;
}
/**
 * Deposit funds into an account in a contract
 * @export
 * @interface InputOneOf4
 */
export interface InputOneOf4 {
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf4
     */
    'input_from_party': Party;
    /**
     * 
     * @type {Party}
     * @memberof InputOneOf4
     */
    'into_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof InputOneOf4
     */
    'of_token': Token;
    /**
     * 
     * @type {number}
     * @memberof InputOneOf4
     */
    'that_deposits': number;
}
/**
 * @type IntervalError
 * A Marlowe transaction interval error.
 * @export
 */
export type IntervalError = IntervalErrorOneOf | IntervalErrorOneOf1;

/**
 * Invalid Marlowe transaction interval.
 * @export
 * @interface IntervalErrorOneOf
 */
export interface IntervalErrorOneOf {
    /**
     * 
     * @type {IntervalErrorOneOfInvalidInterval}
     * @memberof IntervalErrorOneOf
     */
    'invalidInterval': IntervalErrorOneOfInvalidInterval;
}
/**
 * Marlowe transaction interval in past.
 * @export
 * @interface IntervalErrorOneOf1
 */
export interface IntervalErrorOneOf1 {
    /**
     * 
     * @type {IntervalErrorOneOf1IntervalInPastError}
     * @memberof IntervalErrorOneOf1
     */
    'intervalInPastError': IntervalErrorOneOf1IntervalInPastError;
}
/**
 * 
 * @export
 * @interface IntervalErrorOneOf1IntervalInPastError
 */
export interface IntervalErrorOneOf1IntervalInPastError {
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOf1IntervalInPastError
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOf1IntervalInPastError
     */
    'minTime': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOf1IntervalInPastError
     */
    'to': number;
}
/**
 * 
 * @export
 * @interface IntervalErrorOneOfInvalidInterval
 */
export interface IntervalErrorOneOfInvalidInterval {
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOfInvalidInterval
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalErrorOneOfInvalidInterval
     */
    'to': number;
}
/**
 * A bundle of labelled Marlowe objects in define-before-use order.
 * @export
 * @interface LabelledObject
 */
export interface LabelledObject {
    /**
     * An arbitrary text identifier for an object in a Marlowe object bundle.
     * @type {string}
     * @memberof LabelledObject
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof LabelledObject
     */
    'type': LabelledObjectTypeEnum;
    /**
     * 
     * @type {LabelledObjectValue}
     * @memberof LabelledObject
     */
    'value': LabelledObjectValue;
}

export const LabelledObjectTypeEnum = {
    Value: 'value',
    Observation: 'observation',
    Contract: 'contract',
    Party: 'party',
    Token: 'token',
    Action: 'action'
} as const;

export type LabelledObjectTypeEnum = typeof LabelledObjectTypeEnum[keyof typeof LabelledObjectTypeEnum];

/**
 * @type LabelledObjectValue
 * @export
 */
export type LabelledObjectValue = ActionObject | ContractObject | ObservationObject | PartyObject | TokenObject | ValueObject;

/**
 * 
 * @export
 * @interface ListObjectContractHeader
 */
export interface ListObjectContractHeader {
    /**
     * 
     * @type {Array<ListObjectContractHeaderResultsInner>}
     * @memberof ListObjectContractHeader
     */
    'results': Array<ListObjectContractHeaderResultsInner>;
}
/**
 * 
 * @export
 * @interface ListObjectContractHeaderResultsInner
 */
export interface ListObjectContractHeaderResultsInner {
    /**
     * 
     * @type {ListObjectContractHeaderResultsInnerLinks}
     * @memberof ListObjectContractHeaderResultsInner
     */
    'links': ListObjectContractHeaderResultsInnerLinks;
    /**
     * 
     * @type {ContractHeader}
     * @memberof ListObjectContractHeaderResultsInner
     */
    'resource': ContractHeader;
}
/**
 * 
 * @export
 * @interface ListObjectContractHeaderResultsInnerLinks
 */
export interface ListObjectContractHeaderResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof ListObjectContractHeaderResultsInnerLinks
     */
    'contract'?: string;
    /**
     * 
     * @type {string}
     * @memberof ListObjectContractHeaderResultsInnerLinks
     */
    'transactions'?: string;
}
/**
 * 
 * @export
 * @interface ListObjectContractSourceId
 */
export interface ListObjectContractSourceId {
    /**
     * 
     * @type {Array<string>}
     * @memberof ListObjectContractSourceId
     */
    'results': Array<string>;
}
/**
 * 
 * @export
 * @interface ListObjectPayoutHeader
 */
export interface ListObjectPayoutHeader {
    /**
     * 
     * @type {Array<ListObjectPayoutHeaderResultsInner>}
     * @memberof ListObjectPayoutHeader
     */
    'results': Array<ListObjectPayoutHeaderResultsInner>;
}
/**
 * 
 * @export
 * @interface ListObjectPayoutHeaderResultsInner
 */
export interface ListObjectPayoutHeaderResultsInner {
    /**
     * 
     * @type {ListObjectPayoutHeaderResultsInnerLinks}
     * @memberof ListObjectPayoutHeaderResultsInner
     */
    'links': ListObjectPayoutHeaderResultsInnerLinks;
    /**
     * 
     * @type {PayoutHeader}
     * @memberof ListObjectPayoutHeaderResultsInner
     */
    'resource': PayoutHeader;
}
/**
 * 
 * @export
 * @interface ListObjectPayoutHeaderResultsInnerLinks
 */
export interface ListObjectPayoutHeaderResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof ListObjectPayoutHeaderResultsInnerLinks
     */
    'payout'?: string;
}
/**
 * 
 * @export
 * @interface ListObjectTxHeader
 */
export interface ListObjectTxHeader {
    /**
     * 
     * @type {Array<ListObjectTxHeaderResultsInner>}
     * @memberof ListObjectTxHeader
     */
    'results': Array<ListObjectTxHeaderResultsInner>;
}
/**
 * 
 * @export
 * @interface ListObjectTxHeaderResultsInner
 */
export interface ListObjectTxHeaderResultsInner {
    /**
     * 
     * @type {ContractsContractIdTransactionsPost201ResponseLinks}
     * @memberof ListObjectTxHeaderResultsInner
     */
    'links': ContractsContractIdTransactionsPost201ResponseLinks;
    /**
     * 
     * @type {TxHeader}
     * @memberof ListObjectTxHeaderResultsInner
     */
    'resource': TxHeader;
}
/**
 * 
 * @export
 * @interface ListObjectWithdrawalHeader
 */
export interface ListObjectWithdrawalHeader {
    /**
     * 
     * @type {Array<ListObjectWithdrawalHeaderResultsInner>}
     * @memberof ListObjectWithdrawalHeader
     */
    'results': Array<ListObjectWithdrawalHeaderResultsInner>;
}
/**
 * 
 * @export
 * @interface ListObjectWithdrawalHeaderResultsInner
 */
export interface ListObjectWithdrawalHeaderResultsInner {
    /**
     * 
     * @type {WithdrawalsPost201ResponseLinks}
     * @memberof ListObjectWithdrawalHeaderResultsInner
     */
    'links': WithdrawalsPost201ResponseLinks;
    /**
     * 
     * @type {WithdrawalHeader}
     * @memberof ListObjectWithdrawalHeaderResultsInner
     */
    'resource': WithdrawalHeader;
}
/**
 * The on-chain state of a Marlowe contract.
 * @export
 * @interface MarloweState
 */
export interface MarloweState {
    /**
     * 
     * @type {Array<Array<MarloweStateAccountsInnerInner>>}
     * @memberof MarloweState
     */
    'accounts': Array<Array<MarloweStateAccountsInnerInner>>;
    /**
     * 
     * @type {Array<Array<MarloweStateBoundValuesInnerInner>>}
     * @memberof MarloweState
     */
    'boundValues': Array<Array<MarloweStateBoundValuesInnerInner>>;
    /**
     * 
     * @type {Array<Array<MarloweStateChoicesInnerInner>>}
     * @memberof MarloweState
     */
    'choices': Array<Array<MarloweStateChoicesInnerInner>>;
    /**
     * 
     * @type {number}
     * @memberof MarloweState
     */
    'minTime': number;
}
/**
 * @type MarloweStateAccountsInnerInner
 * @export
 */
export type MarloweStateAccountsInnerInner = Array<MarloweStateAccountsInnerInnerOneOfInner> | number;

/**
 * @type MarloweStateAccountsInnerInnerOneOfInner
 * @export
 */
export type MarloweStateAccountsInnerInnerOneOfInner = Party | Token;

/**
 * @type MarloweStateBoundValuesInnerInner
 * @export
 */
export type MarloweStateBoundValuesInnerInner = number | string;

/**
 * @type MarloweStateChoicesInnerInner
 * @export
 */
export type MarloweStateChoicesInnerInner = ChoiceId | number;

/**
 * A version of the Marlowe language.
 * @export
 * @enum {string}
 */

export const MarloweVersion = {
    V1: 'v1'
} as const;

export type MarloweVersion = typeof MarloweVersion[keyof typeof MarloweVersion];


/**
 * Describe the reducibility (Can be Reduced ?) and the applicability (Can Inputs be Applied ?) for a given contract.
 * @export
 * @interface Next
 */
export interface Next {
    /**
     * 
     * @type {ApplicableInputs}
     * @memberof Next
     */
    'applicable_inputs': ApplicableInputs;
    /**
     * Indicates if a given contract can be reduced (apply []) or not.
     * @type {boolean}
     * @memberof Next
     */
    'can_reduce': boolean;
}
/**
 * @type Observation
 * A time-varying expression that evaluates to an integer
 * @export
 */
export type Observation = ObservationOneOf | ObservationOneOf1 | ObservationOneOf2 | ObservationOneOf3 | ObservationOneOf4 | ObservationOneOf5 | ObservationOneOf6 | ObservationOneOf7 | ObservationOneOf8 | boolean;

/**
 * @type ObservationObject
 * A time-varying expression that evaluates to an integer
 * @export
 */
export type ObservationObject = ObservationObjectOneOf | ObservationObjectOneOf1 | ObservationObjectOneOf2 | ObservationObjectOneOf3 | ObservationObjectOneOf4 | ObservationObjectOneOf5 | ObservationObjectOneOf6 | ObservationObjectOneOf7 | ObservationObjectOneOf8 | ValueObjectOneOf8 | boolean;

/**
 * 
 * @export
 * @interface ObservationObjectOneOf
 */
export interface ObservationObjectOneOf {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf
     */
    'and': ObservationObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf
     */
    'both': ObservationObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf1
 */
export interface ObservationObjectOneOf1 {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf1
     */
    'either': ObservationObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf1
     */
    'or': ObservationObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf2
 */
export interface ObservationObjectOneOf2 {
    /**
     * 
     * @type {ObservationObject}
     * @memberof ObservationObjectOneOf2
     */
    'not': ObservationObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf3
 */
export interface ObservationObjectOneOf3 {
    /**
     * 
     * @type {ChoiceIdObject}
     * @memberof ObservationObjectOneOf3
     */
    'chose_something_for': ChoiceIdObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf4
 */
export interface ObservationObjectOneOf4 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf4
     */
    'ge_than': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf4
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf5
 */
export interface ObservationObjectOneOf5 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf5
     */
    'gt': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf5
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf6
 */
export interface ObservationObjectOneOf6 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf6
     */
    'lt': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf6
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf7
 */
export interface ObservationObjectOneOf7 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf7
     */
    'le_than': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf7
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationObjectOneOf8
 */
export interface ObservationObjectOneOf8 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf8
     */
    'equal_to': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ObservationObjectOneOf8
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ObservationOneOf
 */
export interface ObservationOneOf {
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf
     */
    'and': Observation;
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf
     */
    'both': Observation;
}
/**
 * 
 * @export
 * @interface ObservationOneOf1
 */
export interface ObservationOneOf1 {
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf1
     */
    'either': Observation;
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf1
     */
    'or': Observation;
}
/**
 * 
 * @export
 * @interface ObservationOneOf2
 */
export interface ObservationOneOf2 {
    /**
     * 
     * @type {Observation}
     * @memberof ObservationOneOf2
     */
    'not': Observation;
}
/**
 * 
 * @export
 * @interface ObservationOneOf3
 */
export interface ObservationOneOf3 {
    /**
     * 
     * @type {ChoiceId}
     * @memberof ObservationOneOf3
     */
    'chose_something_for': ChoiceId;
}
/**
 * 
 * @export
 * @interface ObservationOneOf4
 */
export interface ObservationOneOf4 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf4
     */
    'ge_than': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf4
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf5
 */
export interface ObservationOneOf5 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf5
     */
    'gt': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf5
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf6
 */
export interface ObservationOneOf6 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf6
     */
    'lt': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf6
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf7
 */
export interface ObservationOneOf7 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf7
     */
    'le_than': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf7
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ObservationOneOf8
 */
export interface ObservationOneOf8 {
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf8
     */
    'equal_to': Value;
    /**
     * 
     * @type {Value}
     * @memberof ObservationOneOf8
     */
    'value': Value;
}
/**
 * @type Party
 * A participant in a contract
 * @export
 */
export type Party = PartyOneOf | PartyOneOf1;

/**
 * @type PartyObject
 * A participant in a contract
 * @export
 */
export type PartyObject = PartyOneOf | PartyOneOf1 | ValueObjectOneOf8;

/**
 * Refers to a party by role name.
 * @export
 * @interface PartyOneOf
 */
export interface PartyOneOf {
    /**
     * 
     * @type {string}
     * @memberof PartyOneOf
     */
    'role_token': string;
}
/**
 * Refers to a party by Cardano address.
 * @export
 * @interface PartyOneOf1
 */
export interface PartyOneOf1 {
    /**
     * A cardano address
     * @type {string}
     * @memberof PartyOneOf1
     */
    'address': string;
}
/**
 * @type Payee
 * A recipient of a payment
 * @export
 */
export type Payee = PayeeOneOf | PayeeOneOf1;

/**
 * @type PayeeObject
 * A recipient of a payment
 * @export
 */
export type PayeeObject = PayeeObjectOneOf | PayeeObjectOneOf1;

/**
 * Pays funds into a party\'s account in the contract.
 * @export
 * @interface PayeeObjectOneOf
 */
export interface PayeeObjectOneOf {
    /**
     * 
     * @type {PartyObject}
     * @memberof PayeeObjectOneOf
     */
    'account': PartyObject;
}
/**
 * Pays funds to a party.
 * @export
 * @interface PayeeObjectOneOf1
 */
export interface PayeeObjectOneOf1 {
    /**
     * 
     * @type {PartyObject}
     * @memberof PayeeObjectOneOf1
     */
    'party': PartyObject;
}
/**
 * Pays funds into a party\'s account in the contract.
 * @export
 * @interface PayeeOneOf
 */
export interface PayeeOneOf {
    /**
     * 
     * @type {Party}
     * @memberof PayeeOneOf
     */
    'account': Party;
}
/**
 * Pays funds to a party.
 * @export
 * @interface PayeeOneOf1
 */
export interface PayeeOneOf1 {
    /**
     * 
     * @type {Party}
     * @memberof PayeeOneOf1
     */
    'party': Party;
}
/**
 * A Marlowe payment.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'amount': number;
    /**
     * 
     * @type {Party}
     * @memberof Payment
     */
    'payment_from': Party;
    /**
     * 
     * @type {Payee}
     * @memberof Payment
     */
    'to': Payee;
    /**
     * 
     * @type {Token}
     * @memberof Payment
     */
    'token': Token;
}
/**
 * 
 * @export
 * @interface Payout
 */
export interface Payout {
    /**
     * 
     * @type {Assets}
     * @memberof Payout
     */
    'assets': Assets;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Payout
     */
    'payoutId': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface PayoutHeader
 */
export interface PayoutHeader {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutHeader
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutHeader
     */
    'payoutId': string;
    /**
     * 
     * @type {AssetId}
     * @memberof PayoutHeader
     */
    'role': AssetId;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutHeader
     */
    'status': PayoutStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof PayoutHeader
     */
    'withdrawalId'?: string;
}


/**
 * 
 * @export
 * @interface PayoutState
 */
export interface PayoutState {
    /**
     * 
     * @type {Assets}
     * @memberof PayoutState
     */
    'assets': Assets;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutState
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutState
     */
    'payoutId': string;
    /**
     * A cardano address
     * @type {string}
     * @memberof PayoutState
     */
    'payoutValidatorAddress': string;
    /**
     * 
     * @type {AssetId}
     * @memberof PayoutState
     */
    'role': AssetId;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutState
     */
    'status': PayoutStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof PayoutState
     */
    'withdrawalId'?: string;
}


/**
 * The status of a payout. Either it is available to be withdrawn, or it has already been withdrawn.
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    Available: 'available',
    Withdrawn: 'withdrawn'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * 
 * @export
 * @interface PayoutsPayoutIdGet200Response
 */
export interface PayoutsPayoutIdGet200Response {
    /**
     * 
     * @type {PayoutsPayoutIdGet200ResponseLinks}
     * @memberof PayoutsPayoutIdGet200Response
     */
    'links': PayoutsPayoutIdGet200ResponseLinks;
    /**
     * 
     * @type {PayoutState}
     * @memberof PayoutsPayoutIdGet200Response
     */
    'resource': PayoutState;
}
/**
 * 
 * @export
 * @interface PayoutsPayoutIdGet200ResponseLinks
 */
export interface PayoutsPayoutIdGet200ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof PayoutsPayoutIdGet200ResponseLinks
     */
    'contract'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutsPayoutIdGet200ResponseLinks
     */
    'transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof PayoutsPayoutIdGet200ResponseLinks
     */
    'withdrawal'?: string;
}
/**
 * A Plutus address.
 * @export
 * @interface PlutusAddress
 */
export interface PlutusAddress {
    /**
     * 
     * @type {PlutusCredential}
     * @memberof PlutusAddress
     */
    'addressCredential': PlutusCredential;
    /**
     * 
     * @type {PlutusStakingCredential}
     * @memberof PlutusAddress
     */
    'addressStakingCredential'?: PlutusStakingCredential;
}
/**
 * @type PlutusCredential
 * A Plutus credential.
 * @export
 */
export type PlutusCredential = PlutusCredentialOneOf | PlutusCredentialOneOf1;

/**
 * A Plutus public key credential.
 * @export
 * @interface PlutusCredentialOneOf
 */
export interface PlutusCredentialOneOf {
    /**
     * 
     * @type {string}
     * @memberof PlutusCredentialOneOf
     */
    'pubKeyCredential': string;
}
/**
 * A Plutus script credential.
 * @export
 * @interface PlutusCredentialOneOf1
 */
export interface PlutusCredentialOneOf1 {
    /**
     * 
     * @type {string}
     * @memberof PlutusCredentialOneOf1
     */
    'scriptCredential': string;
}
/**
 * @type PlutusStakingCredential
 * A Plutus staking credential.
 * @export
 */
export type PlutusStakingCredential = PlutusStakingCredentialOneOf | PlutusStakingCredentialOneOf1;

/**
 * A Plutus staking hash.
 * @export
 * @interface PlutusStakingCredentialOneOf
 */
export interface PlutusStakingCredentialOneOf {
    /**
     * 
     * @type {PlutusCredential}
     * @memberof PlutusStakingCredentialOneOf
     */
    'stakingHash': PlutusCredential;
}
/**
 * A Plutus staking pointer.
 * @export
 * @interface PlutusStakingCredentialOneOf1
 */
export interface PlutusStakingCredentialOneOf1 {
    /**
     * 
     * @type {Array<PlutusStakingCredentialOneOf1StakingHashInner>}
     * @memberof PlutusStakingCredentialOneOf1
     */
    'stakingHash': Array<PlutusStakingCredentialOneOf1StakingHashInner>;
}
/**
 * @type PlutusStakingCredentialOneOf1StakingHashInner
 * @export
 */
export type PlutusStakingCredentialOneOf1StakingHashInner = number;

/**
 * 
 * @export
 * @interface PostContractSourceResponse
 */
export interface PostContractSourceResponse {
    /**
     * The hex-encoded identifier of a Marlowe contract source
     * @type {string}
     * @memberof PostContractSourceResponse
     */
    'contractSourceId': string;
    /**
     * 
     * @type {{ [key: string]: string | undefined; }}
     * @memberof PostContractSourceResponse
     */
    'intermediateIds': { [key: string]: string | undefined; };
}
/**
 * 
 * @export
 * @interface PostContractsRequest
 */
export interface PostContractsRequest {
    /**
     * 
     * @type {PostContractsRequestContract}
     * @memberof PostContractsRequest
     */
    'contract': PostContractsRequestContract;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostContractsRequest
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {number}
     * @memberof PostContractsRequest
     */
    'minUTxODeposit': number;
    /**
     * 
     * @type {RolesConfig}
     * @memberof PostContractsRequest
     */
    'roles'?: RolesConfig;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostContractsRequest
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof PostContractsRequest
     */
    'version': MarloweVersion;
}


/**
 * @type PostContractsRequestContract
 * @export
 */
export type PostContractsRequestContract = Contract | string;

/**
 * 
 * @export
 * @interface PostTransactionsRequest
 */
export interface PostTransactionsRequest {
    /**
     * 
     * @type {Array<Input>}
     * @memberof PostTransactionsRequest
     */
    'inputs': Array<Input>;
    /**
     * 
     * @type {string}
     * @memberof PostTransactionsRequest
     */
    'invalidBefore'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostTransactionsRequest
     */
    'invalidHereafter'?: string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostTransactionsRequest
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof PostTransactionsRequest
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof PostTransactionsRequest
     */
    'version': MarloweVersion;
}


/**
 * 
 * @export
 * @interface PostWithdrawalsRequest
 */
export interface PostWithdrawalsRequest {
    /**
     * 
     * @type {Set<string>}
     * @memberof PostWithdrawalsRequest
     */
    'payouts': Set<string>;
}
/**
 * @type RoleTokenConfig
 * @export
 */
export type RoleTokenConfig = RoleTokenConfigOneOf | string;

/**
 * 
 * @export
 * @interface RoleTokenConfigOneOf
 */
export interface RoleTokenConfigOneOf {
    /**
     * A cardano address
     * @type {string}
     * @memberof RoleTokenConfigOneOf
     */
    'address': string;
    /**
     * 
     * @type {TokenMetadata}
     * @memberof RoleTokenConfigOneOf
     */
    'metadata': TokenMetadata;
}
/**
 * @type RolesConfig
 * @export
 */
export type RolesConfig = string | { [key: string]: RoleTokenConfig | undefined; };

/**
 * Information about the safety of a Marlowe contract and its state.
 * @export
 * @interface SafetyError
 */
export interface SafetyError {
    /**
     * 
     * @type {Party}
     * @memberof SafetyError
     */
    'account-id'?: Party;
    /**
     * 
     * @type {PlutusAddress}
     * @memberof SafetyError
     */
    'address'?: PlutusAddress;
    /**
     * 
     * @type {number}
     * @memberof SafetyError
     */
    'bytes'?: number;
    /**
     * 
     * @type {ChoiceId}
     * @memberof SafetyError
     */
    'choice-id'?: ChoiceId;
    /**
     * 
     * @type {ExBudget}
     * @memberof SafetyError
     */
    'cost'?: ExBudget;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'currency-symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'error': string;
    /**
     * 
     * @type {boolean}
     * @memberof SafetyError
     */
    'fatal': boolean;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'role-name'?: string;
    /**
     * 
     * @type {Token}
     * @memberof SafetyError
     */
    'token'?: Token;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'token-name'?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof SafetyError
     */
    'transaction'?: Transaction;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'value-id'?: string;
    /**
     * 
     * @type {TransactionWarning}
     * @memberof SafetyError
     */
    'warning'?: TransactionWarning;
}
/**
 * 
 * @export
 * @interface TextEnvelope
 */
export interface TextEnvelope {
    /**
     * 
     * @type {string}
     * @memberof TextEnvelope
     */
    'cborHex': string;
    /**
     * 
     * @type {string}
     * @memberof TextEnvelope
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof TextEnvelope
     */
    'type': string;
}
/**
 * A token with a currency symbol (minting policy ID) and token name.
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'currency_symbol': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_name': string;
}
/**
 * Metadata for an NFT, as described by https://cips.cardano.org/cips/cip25/
 * @export
 * @interface TokenMetadata
 */
export interface TokenMetadata {
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {Array<TokenMetadataFile>}
     * @memberof TokenMetadata
     */
    'files'?: Array<TokenMetadataFile>;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'mediaType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TokenMetadataFile
 */
export interface TokenMetadataFile {
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'mediaType': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'src': string;
}
/**
 * @type TokenObject
 * A token with a currency symbol (minting policy ID) and token name.
 * @export
 */
export type TokenObject = Token | ValueObjectOneOf8;

/**
 * Information about a Marlowe transaction.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {Contract}
     * @memberof Transaction
     */
    'contract': Contract;
    /**
     * 
     * @type {TransactionInput}
     * @memberof Transaction
     */
    'input': TransactionInput;
    /**
     * 
     * @type {TransactionOutput}
     * @memberof Transaction
     */
    'output': TransactionOutput;
    /**
     * 
     * @type {MarloweState}
     * @memberof Transaction
     */
    'state': MarloweState;
}
/**
 * @type TransactionError
 * A Marlowe transaction error.
 * @export
 */
export type TransactionError = TransactionErrorOneOf | string;

/**
 * An invalid time interval.
 * @export
 * @interface TransactionErrorOneOf
 */
export interface TransactionErrorOneOf {
    /**
     * 
     * @type {IntervalError}
     * @memberof TransactionErrorOneOf
     */
    'context': IntervalError;
    /**
     * 
     * @type {string}
     * @memberof TransactionErrorOneOf
     */
    'error': TransactionErrorOneOfErrorEnum;
}

export const TransactionErrorOneOfErrorEnum = {
    TeIntervalError: 'TEIntervalError'
} as const;

export type TransactionErrorOneOfErrorEnum = typeof TransactionErrorOneOfErrorEnum[keyof typeof TransactionErrorOneOfErrorEnum];

/**
 * Marlowe transaction input.
 * @export
 * @interface TransactionInput
 */
export interface TransactionInput {
    /**
     * 
     * @type {Array<Input>}
     * @memberof TransactionInput
     */
    'tx_inputs': Array<Input>;
    /**
     * 
     * @type {TransactionInputTxInterval}
     * @memberof TransactionInput
     */
    'tx_interval': TransactionInputTxInterval;
}
/**
 * Time interval.
 * @export
 * @interface TransactionInputTxInterval
 */
export interface TransactionInputTxInterval {
    /**
     * 
     * @type {number}
     * @memberof TransactionInputTxInterval
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionInputTxInterval
     */
    'to': number;
}
/**
 * @type TransactionOutput
 * Marlowe transaction output.
 * @export
 */
export type TransactionOutput = TransactionOutputOneOf | TransactionOutputOneOf1;

/**
 * Marlowe transaction output information.
 * @export
 * @interface TransactionOutputOneOf
 */
export interface TransactionOutputOneOf {
    /**
     * 
     * @type {Contract}
     * @memberof TransactionOutputOneOf
     */
    'contract': Contract;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof TransactionOutputOneOf
     */
    'payments': Array<Payment>;
    /**
     * 
     * @type {MarloweState}
     * @memberof TransactionOutputOneOf
     */
    'state': MarloweState;
    /**
     * 
     * @type {Array<TransactionWarning>}
     * @memberof TransactionOutputOneOf
     */
    'warnings': Array<TransactionWarning>;
}
/**
 * Marlowe transaction error.
 * @export
 * @interface TransactionOutputOneOf1
 */
export interface TransactionOutputOneOf1 {
    /**
     * 
     * @type {TransactionError}
     * @memberof TransactionOutputOneOf1
     */
    'transaction_error': TransactionError;
}
/**
 * @type TransactionWarning
 * A transaction semantics warning.
 * @export
 */
export type TransactionWarning = TransactionWarningOneOf | TransactionWarningOneOf1 | TransactionWarningOneOf2 | TransactionWarningOneOf3 | string;

/**
 * A warning for a non-positive deposit.
 * @export
 * @interface TransactionWarningOneOf
 */
export interface TransactionWarningOneOf {
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf
     */
    'asked_to_deposit': number;
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf
     */
    'in_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof TransactionWarningOneOf
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf
     */
    'party': Party;
}
/**
 * A warning for a non-positive payment.
 * @export
 * @interface TransactionWarningOneOf1
 */
export interface TransactionWarningOneOf1 {
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf1
     */
    'account': Party;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf1
     */
    'asked_to_pay': number;
    /**
     * 
     * @type {Token}
     * @memberof TransactionWarningOneOf1
     */
    'of_token': Token;
    /**
     * 
     * @type {Payee}
     * @memberof TransactionWarningOneOf1
     */
    'to_payee': Payee;
}
/**
 * A warning for partial payment.
 * @export
 * @interface TransactionWarningOneOf2
 */
export interface TransactionWarningOneOf2 {
    /**
     * 
     * @type {Party}
     * @memberof TransactionWarningOneOf2
     */
    'account': Party;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf2
     */
    'asked_to_pay': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf2
     */
    'but_only_paid': number;
    /**
     * 
     * @type {Token}
     * @memberof TransactionWarningOneOf2
     */
    'of_token': Token;
    /**
     * 
     * @type {Payee}
     * @memberof TransactionWarningOneOf2
     */
    'to_payee': Payee;
}
/**
 * A variable-name shadowing warning.
 * @export
 * @interface TransactionWarningOneOf3
 */
export interface TransactionWarningOneOf3 {
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf3
     */
    'had_value': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionWarningOneOf3
     */
    'is_now_assigned': number;
    /**
     * 
     * @type {string}
     * @memberof TransactionWarningOneOf3
     */
    'value_id': string;
}
/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {Assets}
     * @memberof Tx
     */
    'assets': Assets;
    /**
     * 
     * @type {BlockHeader}
     * @memberof Tx
     */
    'block'?: BlockHeader;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Tx
     */
    'consumingTx'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'inputUtxo': string;
    /**
     * 
     * @type {Array<Input>}
     * @memberof Tx
     */
    'inputs': Array<Input>;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'invalidBefore': string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'invalidHereafter': string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof Tx
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {Contract}
     * @memberof Tx
     */
    'outputContract'?: Contract;
    /**
     * 
     * @type {MarloweState}
     * @memberof Tx
     */
    'outputState'?: MarloweState;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'outputUtxo'?: string;
    /**
     * 
     * @type {Array<Payout>}
     * @memberof Tx
     */
    'payouts': Array<Payout>;
    /**
     * 
     * @type {TxStatus}
     * @memberof Tx
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof Tx
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Tx
     */
    'transactionId': string;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof Tx
     */
    'txBody'?: TextEnvelope;
}


/**
 * 
 * @export
 * @interface TxHeader
 */
export interface TxHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof TxHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof TxHeader
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof TxHeader
     */
    'contractId': string;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof TxHeader
     */
    'metadata': { [key: string]: any | undefined; };
    /**
     * 
     * @type {TxStatus}
     * @memberof TxHeader
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: any | undefined; }}
     * @memberof TxHeader
     */
    'tags': { [key: string]: any | undefined; };
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof TxHeader
     */
    'transactionId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof TxHeader
     */
    'utxo'?: string;
}


/**
 * The status of a transaction on the local node.
 * @export
 * @enum {string}
 */

export const TxStatus = {
    Unsigned: 'unsigned',
    Submitted: 'submitted',
    Confirmed: 'confirmed'
} as const;

export type TxStatus = typeof TxStatus[keyof typeof TxStatus];


/**
 * @type Value
 * A time-varying expression that evaluates to a boolean
 * @export
 */
export type Value = ValueOneOf | ValueOneOf1 | ValueOneOf2 | ValueOneOf3 | ValueOneOf4 | ValueOneOf5 | ValueOneOf6 | ValueOneOf7 | ValueOneOf8 | number | string;

/**
 * @type ValueObject
 * A time-varying expression that evaluates to a boolean
 * @export
 */
export type ValueObject = ValueObjectOneOf | ValueObjectOneOf1 | ValueObjectOneOf2 | ValueObjectOneOf3 | ValueObjectOneOf4 | ValueObjectOneOf5 | ValueObjectOneOf6 | ValueObjectOneOf7 | ValueObjectOneOf8 | ValueOneOf7 | number | string;

/**
 * 
 * @export
 * @interface ValueObjectOneOf
 */
export interface ValueObjectOneOf {
    /**
     * 
     * @type {TokenObject}
     * @memberof ValueObjectOneOf
     */
    'amount_of_token': TokenObject;
    /**
     * 
     * @type {PartyObject}
     * @memberof ValueObjectOneOf
     */
    'in_account': PartyObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf1
 */
export interface ValueObjectOneOf1 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf1
     */
    'negate': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf2
 */
export interface ValueObjectOneOf2 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf2
     */
    'add': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf2
     */
    'and': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf3
 */
export interface ValueObjectOneOf3 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf3
     */
    'minus': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf3
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf4
 */
export interface ValueObjectOneOf4 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf4
     */
    'multiply': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf4
     */
    'times': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf5
 */
export interface ValueObjectOneOf5 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf5
     */
    'by': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf5
     */
    'divide': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf6
 */
export interface ValueObjectOneOf6 {
    /**
     * 
     * @type {ChoiceIdObject}
     * @memberof ValueObjectOneOf6
     */
    'value_of_choice': ChoiceIdObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf7
 */
export interface ValueObjectOneOf7 {
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf7
     */
    'else': ValueObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof ValueObjectOneOf7
     */
    'if': ObservationObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof ValueObjectOneOf7
     */
    'then': ValueObject;
}
/**
 * 
 * @export
 * @interface ValueObjectOneOf8
 */
export interface ValueObjectOneOf8 {
    /**
     * An arbitrary text identifier for an object in a Marlowe object bundle.
     * @type {string}
     * @memberof ValueObjectOneOf8
     */
    'ref': string;
}
/**
 * 
 * @export
 * @interface ValueOneOf
 */
export interface ValueOneOf {
    /**
     * 
     * @type {Token}
     * @memberof ValueOneOf
     */
    'amount_of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof ValueOneOf
     */
    'in_account': Party;
}
/**
 * 
 * @export
 * @interface ValueOneOf1
 */
export interface ValueOneOf1 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf1
     */
    'negate': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf2
 */
export interface ValueOneOf2 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf2
     */
    'add': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf2
     */
    'and': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf3
 */
export interface ValueOneOf3 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf3
     */
    'minus': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf3
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf4
 */
export interface ValueOneOf4 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf4
     */
    'multiply': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf4
     */
    'times': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf5
 */
export interface ValueOneOf5 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf5
     */
    'by': Value;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf5
     */
    'divide': Value;
}
/**
 * 
 * @export
 * @interface ValueOneOf6
 */
export interface ValueOneOf6 {
    /**
     * 
     * @type {ChoiceId}
     * @memberof ValueOneOf6
     */
    'value_of_choice': ChoiceId;
}
/**
 * 
 * @export
 * @interface ValueOneOf7
 */
export interface ValueOneOf7 {
    /**
     * 
     * @type {string}
     * @memberof ValueOneOf7
     */
    'use_value': string;
}
/**
 * 
 * @export
 * @interface ValueOneOf8
 */
export interface ValueOneOf8 {
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf8
     */
    'else': Value;
    /**
     * 
     * @type {Observation}
     * @memberof ValueOneOf8
     */
    'if': Observation;
    /**
     * 
     * @type {Value}
     * @memberof ValueOneOf8
     */
    'then': Value;
}
/**
 * 
 * @export
 * @interface Withdrawal
 */
export interface Withdrawal {
    /**
     * 
     * @type {BlockHeader}
     * @memberof Withdrawal
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {Set<PayoutHeader>}
     * @memberof Withdrawal
     */
    'payouts': Set<PayoutHeader>;
    /**
     * 
     * @type {TxStatus}
     * @memberof Withdrawal
     */
    'status': TxStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Withdrawal
     */
    'withdrawalId': string;
}


/**
 * 
 * @export
 * @interface WithdrawalHeader
 */
export interface WithdrawalHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof WithdrawalHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {TxStatus}
     * @memberof WithdrawalHeader
     */
    'status': TxStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof WithdrawalHeader
     */
    'withdrawalId': string;
}


/**
 * 
 * @export
 * @interface WithdrawalsPost201Response
 */
export interface WithdrawalsPost201Response {
    /**
     * 
     * @type {WithdrawalsPost201ResponseLinks}
     * @memberof WithdrawalsPost201Response
     */
    'links': WithdrawalsPost201ResponseLinks;
    /**
     * 
     * @type {ApplyInputsTxEnvelope}
     * @memberof WithdrawalsPost201Response
     */
    'resource': ApplyInputsTxEnvelope;
}
/**
 * 
 * @export
 * @interface WithdrawalsPost201ResponseLinks
 */
export interface WithdrawalsPost201ResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof WithdrawalsPost201ResponseLinks
     */
    'withdrawal'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdGet: async (contractId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdGet', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} validityStart 
         * @param {string} validityEnd 
         * @param {Array<string>} [party] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdNextGet: async (contractId: string, validityStart: string, validityEnd: string, party?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdNextGet', 'contractId', contractId)
            // verify required parameter 'validityStart' is not null or undefined
            assertParamExists('contractsContractIdNextGet', 'validityStart', validityStart)
            // verify required parameter 'validityEnd' is not null or undefined
            assertParamExists('contractsContractIdNextGet', 'validityEnd', validityEnd)
            const localVarPath = `/contracts/{contractId}/next`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (validityStart !== undefined) {
                localVarQueryParameter['validityStart'] = validityStart;
            }

            if (validityEnd !== undefined) {
                localVarQueryParameter['validityEnd'] = validityEnd;
            }

            if (party) {
                localVarQueryParameter['party'] = party;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdPut: async (contractId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdPut', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsGet: async (contractId: string, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdTransactionsGet', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}/transactions`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostTransactionsRequest} [postTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsPost: async (contractId: string, xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postTransactionsRequest?: PostTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdTransactionsPost', 'contractId', contractId)
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('contractsContractIdTransactionsPost', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/contracts/{contractId}/transactions`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsTransactionIdGet: async (contractId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdTransactionsTransactionIdGet', 'contractId', contractId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('contractsContractIdTransactionsTransactionIdGet', 'transactionId', transactionId)
            const localVarPath = `/contracts/{contractId}/transactions/{transactionId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsTransactionIdPut: async (contractId: string, transactionId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('contractsContractIdTransactionsTransactionIdPut', 'contractId', contractId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('contractsContractIdTransactionsTransactionIdPut', 'transactionId', transactionId)
            const localVarPath = `/contracts/{contractId}/transactions/{transactionId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [roleCurrency] 
         * @param {Array<string>} [tag] 
         * @param {Array<string>} [partyAddress] 
         * @param {Array<string>} [partyRole] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsGet: async (roleCurrency?: Array<string>, tag?: Array<string>, partyAddress?: Array<string>, partyRole?: Array<string>, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleCurrency) {
                localVarQueryParameter['roleCurrency'] = roleCurrency;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (partyAddress) {
                localVarQueryParameter['partyAddress'] = partyAddress;
            }

            if (partyRole) {
                localVarQueryParameter['partyRole'] = partyRole;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xChangeAddress 
         * @param {string} [xStakeAddress] 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostContractsRequest} [postContractsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsPost: async (xChangeAddress: string, xStakeAddress?: string, xAddress?: string, xCollateralUTxO?: string, postContractsRequest?: PostContractsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('contractsPost', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xStakeAddress != null) {
                localVarHeaderParameter['X-Stake-Address'] = String(xStakeAddress);
            }

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postContractsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesContractSourceIdAdjacencyGet: async (contractSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('contractsSourcesContractSourceIdAdjacencyGet', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}/adjacency`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesContractSourceIdClosureGet: async (contractSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('contractsSourcesContractSourceIdClosureGet', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}/closure`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} contractSourceId 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesContractSourceIdGet: async (contractSourceId: string, expand?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('contractsSourcesContractSourceIdGet', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} main 
         * @param {Array<LabelledObject>} [labelledObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesPost: async (main: string, labelledObject?: Array<LabelledObject>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'main' is not null or undefined
            assertParamExists('contractsSourcesPost', 'main', main)
            const localVarPath = `/contracts/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (main !== undefined) {
                localVarQueryParameter['main'] = main;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labelledObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheckGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [contractId] 
         * @param {Array<string>} [roleToken] 
         * @param {PayoutsGetStatusEnum} [status] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsGet: async (contractId?: Array<string>, roleToken?: Array<string>, status?: PayoutsGetStatusEnum, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (roleToken) {
                localVarQueryParameter['roleToken'] = roleToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} payoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsPayoutIdGet: async (payoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('payoutsPayoutIdGet', 'payoutId', payoutId)
            const localVarPath = `/payouts/{payoutId}`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Array<string>} [roleCurrency] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsGet: async (roleCurrency?: Array<string>, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleCurrency) {
                localVarQueryParameter['roleCurrency'] = roleCurrency;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostWithdrawalsRequest} [postWithdrawalsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsPost: async (xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postWithdrawalsRequest?: PostWithdrawalsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('withdrawalsPost', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postWithdrawalsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsWithdrawalIdGet: async (withdrawalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('withdrawalsWithdrawalIdGet', 'withdrawalId', withdrawalId)
            const localVarPath = `/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} withdrawalId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsWithdrawalIdPut: async (withdrawalId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('withdrawalsWithdrawalIdPut', 'withdrawalId', withdrawalId)
            const localVarPath = `/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdGet(contractId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsContractIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdGet(contractId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} validityStart 
         * @param {string} validityEnd 
         * @param {Array<string>} [party] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdNextGet(contractId: string, validityStart: string, validityEnd: string, party?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Next>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdNextGet(contractId, validityStart, validityEnd, party, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdPut(contractId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdPut(contractId, textEnvelope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdTransactionsGet(contractId: string, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListObjectTxHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdTransactionsGet(contractId, range, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostTransactionsRequest} [postTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdTransactionsPost(contractId: string, xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postTransactionsRequest?: PostTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsContractIdTransactionsPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdTransactionsPost(contractId, xChangeAddress, xAddress, xCollateralUTxO, postTransactionsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdTransactionsTransactionIdGet(contractId: string, transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsContractIdTransactionsTransactionIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdTransactionsTransactionIdGet(contractId, transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsContractIdTransactionsTransactionIdPut(contractId: string, transactionId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsContractIdTransactionsTransactionIdPut(contractId, transactionId, textEnvelope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [roleCurrency] 
         * @param {Array<string>} [tag] 
         * @param {Array<string>} [partyAddress] 
         * @param {Array<string>} [partyRole] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsGet(roleCurrency?: Array<string>, tag?: Array<string>, partyAddress?: Array<string>, partyRole?: Array<string>, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListObjectContractHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsGet(roleCurrency, tag, partyAddress, partyRole, range, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xChangeAddress 
         * @param {string} [xStakeAddress] 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostContractsRequest} [postContractsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsPost(xChangeAddress: string, xStakeAddress?: string, xAddress?: string, xCollateralUTxO?: string, postContractsRequest?: PostContractsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractsPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsPost(xChangeAddress, xStakeAddress, xAddress, xCollateralUTxO, postContractsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSourcesContractSourceIdAdjacencyGet(contractSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListObjectContractSourceId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSourcesContractSourceIdAdjacencyGet(contractSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSourcesContractSourceIdClosureGet(contractSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListObjectContractSourceId>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSourcesContractSourceIdClosureGet(contractSourceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} contractSourceId 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSourcesContractSourceIdGet(contractSourceId: string, expand?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSourcesContractSourceIdGet(contractSourceId, expand, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} main 
         * @param {Array<LabelledObject>} [labelledObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contractsSourcesPost(main: string, labelledObject?: Array<LabelledObject>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContractSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contractsSourcesPost(main, labelledObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheckGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheckGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [contractId] 
         * @param {Array<string>} [roleToken] 
         * @param {PayoutsGetStatusEnum} [status] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutsGet(contractId?: Array<string>, roleToken?: Array<string>, status?: PayoutsGetStatusEnum, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListObjectPayoutHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutsGet(contractId, roleToken, status, range, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} payoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async payoutsPayoutIdGet(payoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PayoutsPayoutIdGet200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.payoutsPayoutIdGet(payoutId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {Array<string>} [roleCurrency] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawalsGet(roleCurrency?: Array<string>, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListObjectWithdrawalHeader>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawalsGet(roleCurrency, range, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostWithdrawalsRequest} [postWithdrawalsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawalsPost(xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postWithdrawalsRequest?: PostWithdrawalsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawalsPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawalsPost(xChangeAddress, xAddress, xCollateralUTxO, postWithdrawalsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} withdrawalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawalsWithdrawalIdGet(withdrawalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Withdrawal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawalsWithdrawalIdGet(withdrawalId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {string} withdrawalId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawalsWithdrawalIdPut(withdrawalId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawalsWithdrawalIdPut(withdrawalId, textEnvelope, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @param {DefaultApiContractsContractIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdGet(requestParameters: DefaultApiContractsContractIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ContractsContractIdGet200Response> {
            return localVarFp.contractsContractIdGet(requestParameters.contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsContractIdNextGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdNextGet(requestParameters: DefaultApiContractsContractIdNextGetRequest, options?: AxiosRequestConfig): AxiosPromise<Next> {
            return localVarFp.contractsContractIdNextGet(requestParameters.contractId, requestParameters.validityStart, requestParameters.validityEnd, requestParameters.party, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsContractIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdPut(requestParameters: DefaultApiContractsContractIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contractsContractIdPut(requestParameters.contractId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsContractIdTransactionsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsGet(requestParameters: DefaultApiContractsContractIdTransactionsGetRequest, options?: AxiosRequestConfig): AxiosPromise<ListObjectTxHeader> {
            return localVarFp.contractsContractIdTransactionsGet(requestParameters.contractId, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsContractIdTransactionsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsPost(requestParameters: DefaultApiContractsContractIdTransactionsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ContractsContractIdTransactionsPost201Response> {
            return localVarFp.contractsContractIdTransactionsPost(requestParameters.contractId, requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsContractIdTransactionsTransactionIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsTransactionIdGet(requestParameters: DefaultApiContractsContractIdTransactionsTransactionIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<ContractsContractIdTransactionsTransactionIdGet200Response> {
            return localVarFp.contractsContractIdTransactionsTransactionIdGet(requestParameters.contractId, requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsContractIdTransactionsTransactionIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsContractIdTransactionsTransactionIdPut(requestParameters: DefaultApiContractsContractIdTransactionsTransactionIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.contractsContractIdTransactionsTransactionIdPut(requestParameters.contractId, requestParameters.transactionId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsGet(requestParameters: DefaultApiContractsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ListObjectContractHeader> {
            return localVarFp.contractsGet(requestParameters.roleCurrency, requestParameters.tag, requestParameters.partyAddress, requestParameters.partyRole, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsPost(requestParameters: DefaultApiContractsPostRequest, options?: AxiosRequestConfig): AxiosPromise<ContractsPost201Response> {
            return localVarFp.contractsPost(requestParameters.xChangeAddress, requestParameters.xStakeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postContractsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsSourcesContractSourceIdAdjacencyGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesContractSourceIdAdjacencyGet(requestParameters: DefaultApiContractsSourcesContractSourceIdAdjacencyGetRequest, options?: AxiosRequestConfig): AxiosPromise<ListObjectContractSourceId> {
            return localVarFp.contractsSourcesContractSourceIdAdjacencyGet(requestParameters.contractSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsSourcesContractSourceIdClosureGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesContractSourceIdClosureGet(requestParameters: DefaultApiContractsSourcesContractSourceIdClosureGetRequest, options?: AxiosRequestConfig): AxiosPromise<ListObjectContractSourceId> {
            return localVarFp.contractsSourcesContractSourceIdClosureGet(requestParameters.contractSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsSourcesContractSourceIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesContractSourceIdGet(requestParameters: DefaultApiContractsSourcesContractSourceIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.contractsSourcesContractSourceIdGet(requestParameters.contractSourceId, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiContractsSourcesPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contractsSourcesPost(requestParameters: DefaultApiContractsSourcesPostRequest, options?: AxiosRequestConfig): AxiosPromise<PostContractSourceResponse> {
            return localVarFp.contractsSourcesPost(requestParameters.main, requestParameters.labelledObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheckGet(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthcheckGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiPayoutsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsGet(requestParameters: DefaultApiPayoutsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ListObjectPayoutHeader> {
            return localVarFp.payoutsGet(requestParameters.contractId, requestParameters.roleToken, requestParameters.status, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiPayoutsPayoutIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        payoutsPayoutIdGet(requestParameters: DefaultApiPayoutsPayoutIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<PayoutsPayoutIdGet200Response> {
            return localVarFp.payoutsPayoutIdGet(requestParameters.payoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiWithdrawalsGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsGet(requestParameters: DefaultApiWithdrawalsGetRequest = {}, options?: AxiosRequestConfig): AxiosPromise<ListObjectWithdrawalHeader> {
            return localVarFp.withdrawalsGet(requestParameters.roleCurrency, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiWithdrawalsPostRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsPost(requestParameters: DefaultApiWithdrawalsPostRequest, options?: AxiosRequestConfig): AxiosPromise<WithdrawalsPost201Response> {
            return localVarFp.withdrawalsPost(requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postWithdrawalsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiWithdrawalsWithdrawalIdGetRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsWithdrawalIdGet(requestParameters: DefaultApiWithdrawalsWithdrawalIdGetRequest, options?: AxiosRequestConfig): AxiosPromise<Withdrawal> {
            return localVarFp.withdrawalsWithdrawalIdGet(requestParameters.withdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultApiWithdrawalsWithdrawalIdPutRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawalsWithdrawalIdPut(requestParameters: DefaultApiWithdrawalsWithdrawalIdPutRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.withdrawalsWithdrawalIdPut(requestParameters.withdrawalId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for contractsContractIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsContractIdGetRequest
 */
export interface DefaultApiContractsContractIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdGet
     */
    readonly contractId: string
}

/**
 * Request parameters for contractsContractIdNextGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsContractIdNextGetRequest
 */
export interface DefaultApiContractsContractIdNextGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdNextGet
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdNextGet
     */
    readonly validityStart: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdNextGet
     */
    readonly validityEnd: string

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiContractsContractIdNextGet
     */
    readonly party?: Array<string>
}

/**
 * Request parameters for contractsContractIdPut operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsContractIdPutRequest
 */
export interface DefaultApiContractsContractIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdPut
     */
    readonly contractId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiContractsContractIdPut
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for contractsContractIdTransactionsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsContractIdTransactionsGetRequest
 */
export interface DefaultApiContractsContractIdTransactionsGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsGet
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsGet
     */
    readonly range?: string
}

/**
 * Request parameters for contractsContractIdTransactionsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsContractIdTransactionsPostRequest
 */
export interface DefaultApiContractsContractIdTransactionsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsPost
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsPost
     */
    readonly xChangeAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsPost
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsPost
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostTransactionsRequest}
     * @memberof DefaultApiContractsContractIdTransactionsPost
     */
    readonly postTransactionsRequest?: PostTransactionsRequest
}

/**
 * Request parameters for contractsContractIdTransactionsTransactionIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsContractIdTransactionsTransactionIdGetRequest
 */
export interface DefaultApiContractsContractIdTransactionsTransactionIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsTransactionIdGet
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsTransactionIdGet
     */
    readonly transactionId: string
}

/**
 * Request parameters for contractsContractIdTransactionsTransactionIdPut operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsContractIdTransactionsTransactionIdPutRequest
 */
export interface DefaultApiContractsContractIdTransactionsTransactionIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsTransactionIdPut
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsContractIdTransactionsTransactionIdPut
     */
    readonly transactionId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiContractsContractIdTransactionsTransactionIdPut
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for contractsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsGetRequest
 */
export interface DefaultApiContractsGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiContractsGet
     */
    readonly roleCurrency?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiContractsGet
     */
    readonly tag?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiContractsGet
     */
    readonly partyAddress?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiContractsGet
     */
    readonly partyRole?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsGet
     */
    readonly range?: string
}

/**
 * Request parameters for contractsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsPostRequest
 */
export interface DefaultApiContractsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsPost
     */
    readonly xChangeAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsPost
     */
    readonly xStakeAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsPost
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsPost
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostContractsRequest}
     * @memberof DefaultApiContractsPost
     */
    readonly postContractsRequest?: PostContractsRequest
}

/**
 * Request parameters for contractsSourcesContractSourceIdAdjacencyGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsSourcesContractSourceIdAdjacencyGetRequest
 */
export interface DefaultApiContractsSourcesContractSourceIdAdjacencyGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsSourcesContractSourceIdAdjacencyGet
     */
    readonly contractSourceId: string
}

/**
 * Request parameters for contractsSourcesContractSourceIdClosureGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsSourcesContractSourceIdClosureGetRequest
 */
export interface DefaultApiContractsSourcesContractSourceIdClosureGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsSourcesContractSourceIdClosureGet
     */
    readonly contractSourceId: string
}

/**
 * Request parameters for contractsSourcesContractSourceIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsSourcesContractSourceIdGetRequest
 */
export interface DefaultApiContractsSourcesContractSourceIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsSourcesContractSourceIdGet
     */
    readonly contractSourceId: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiContractsSourcesContractSourceIdGet
     */
    readonly expand?: boolean
}

/**
 * Request parameters for contractsSourcesPost operation in DefaultApi.
 * @export
 * @interface DefaultApiContractsSourcesPostRequest
 */
export interface DefaultApiContractsSourcesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiContractsSourcesPost
     */
    readonly main: string

    /**
     * 
     * @type {Array<LabelledObject>}
     * @memberof DefaultApiContractsSourcesPost
     */
    readonly labelledObject?: Array<LabelledObject>
}

/**
 * Request parameters for payoutsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiPayoutsGetRequest
 */
export interface DefaultApiPayoutsGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiPayoutsGet
     */
    readonly contractId?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiPayoutsGet
     */
    readonly roleToken?: Array<string>

    /**
     * 
     * @type {'available' | 'withdrawn'}
     * @memberof DefaultApiPayoutsGet
     */
    readonly status?: PayoutsGetStatusEnum

    /**
     * 
     * @type {string}
     * @memberof DefaultApiPayoutsGet
     */
    readonly range?: string
}

/**
 * Request parameters for payoutsPayoutIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiPayoutsPayoutIdGetRequest
 */
export interface DefaultApiPayoutsPayoutIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiPayoutsPayoutIdGet
     */
    readonly payoutId: string
}

/**
 * Request parameters for withdrawalsGet operation in DefaultApi.
 * @export
 * @interface DefaultApiWithdrawalsGetRequest
 */
export interface DefaultApiWithdrawalsGetRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiWithdrawalsGet
     */
    readonly roleCurrency?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawalsGet
     */
    readonly range?: string
}

/**
 * Request parameters for withdrawalsPost operation in DefaultApi.
 * @export
 * @interface DefaultApiWithdrawalsPostRequest
 */
export interface DefaultApiWithdrawalsPostRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawalsPost
     */
    readonly xChangeAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawalsPost
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawalsPost
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostWithdrawalsRequest}
     * @memberof DefaultApiWithdrawalsPost
     */
    readonly postWithdrawalsRequest?: PostWithdrawalsRequest
}

/**
 * Request parameters for withdrawalsWithdrawalIdGet operation in DefaultApi.
 * @export
 * @interface DefaultApiWithdrawalsWithdrawalIdGetRequest
 */
export interface DefaultApiWithdrawalsWithdrawalIdGetRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawalsWithdrawalIdGet
     */
    readonly withdrawalId: string
}

/**
 * Request parameters for withdrawalsWithdrawalIdPut operation in DefaultApi.
 * @export
 * @interface DefaultApiWithdrawalsWithdrawalIdPutRequest
 */
export interface DefaultApiWithdrawalsWithdrawalIdPutRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawalsWithdrawalIdPut
     */
    readonly withdrawalId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiWithdrawalsWithdrawalIdPut
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @param {DefaultApiContractsContractIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsContractIdGet(requestParameters: DefaultApiContractsContractIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsContractIdGet(requestParameters.contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsContractIdNextGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsContractIdNextGet(requestParameters: DefaultApiContractsContractIdNextGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsContractIdNextGet(requestParameters.contractId, requestParameters.validityStart, requestParameters.validityEnd, requestParameters.party, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsContractIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsContractIdPut(requestParameters: DefaultApiContractsContractIdPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsContractIdPut(requestParameters.contractId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsContractIdTransactionsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsContractIdTransactionsGet(requestParameters: DefaultApiContractsContractIdTransactionsGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsContractIdTransactionsGet(requestParameters.contractId, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsContractIdTransactionsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsContractIdTransactionsPost(requestParameters: DefaultApiContractsContractIdTransactionsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsContractIdTransactionsPost(requestParameters.contractId, requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsContractIdTransactionsTransactionIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsContractIdTransactionsTransactionIdGet(requestParameters: DefaultApiContractsContractIdTransactionsTransactionIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsContractIdTransactionsTransactionIdGet(requestParameters.contractId, requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsContractIdTransactionsTransactionIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsContractIdTransactionsTransactionIdPut(requestParameters: DefaultApiContractsContractIdTransactionsTransactionIdPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsContractIdTransactionsTransactionIdPut(requestParameters.contractId, requestParameters.transactionId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsGet(requestParameters: DefaultApiContractsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsGet(requestParameters.roleCurrency, requestParameters.tag, requestParameters.partyAddress, requestParameters.partyRole, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsPost(requestParameters: DefaultApiContractsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsPost(requestParameters.xChangeAddress, requestParameters.xStakeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postContractsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsSourcesContractSourceIdAdjacencyGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsSourcesContractSourceIdAdjacencyGet(requestParameters: DefaultApiContractsSourcesContractSourceIdAdjacencyGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsSourcesContractSourceIdAdjacencyGet(requestParameters.contractSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsSourcesContractSourceIdClosureGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsSourcesContractSourceIdClosureGet(requestParameters: DefaultApiContractsSourcesContractSourceIdClosureGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsSourcesContractSourceIdClosureGet(requestParameters.contractSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsSourcesContractSourceIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsSourcesContractSourceIdGet(requestParameters: DefaultApiContractsSourcesContractSourceIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsSourcesContractSourceIdGet(requestParameters.contractSourceId, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiContractsSourcesPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public contractsSourcesPost(requestParameters: DefaultApiContractsSourcesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).contractsSourcesPost(requestParameters.main, requestParameters.labelledObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthcheckGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthcheckGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiPayoutsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payoutsGet(requestParameters: DefaultApiPayoutsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payoutsGet(requestParameters.contractId, requestParameters.roleToken, requestParameters.status, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiPayoutsPayoutIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public payoutsPayoutIdGet(requestParameters: DefaultApiPayoutsPayoutIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).payoutsPayoutIdGet(requestParameters.payoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiWithdrawalsGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public withdrawalsGet(requestParameters: DefaultApiWithdrawalsGetRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).withdrawalsGet(requestParameters.roleCurrency, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiWithdrawalsPostRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public withdrawalsPost(requestParameters: DefaultApiWithdrawalsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).withdrawalsPost(requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postWithdrawalsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiWithdrawalsWithdrawalIdGetRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public withdrawalsWithdrawalIdGet(requestParameters: DefaultApiWithdrawalsWithdrawalIdGetRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).withdrawalsWithdrawalIdGet(requestParameters.withdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultApiWithdrawalsWithdrawalIdPutRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public withdrawalsWithdrawalIdPut(requestParameters: DefaultApiWithdrawalsWithdrawalIdPutRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).withdrawalsWithdrawalIdPut(requestParameters.withdrawalId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PayoutsGetStatusEnum = {
    Available: 'available',
    Withdrawn: 'withdrawn'
} as const;
export type PayoutsGetStatusEnum = typeof PayoutsGetStatusEnum[keyof typeof PayoutsGetStatusEnum];


