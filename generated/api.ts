/* tslint:disable */
/* eslint-disable */
/**
 * Marlowe Runtime REST API
 * REST API for Marlowe Runtime
 *
 * The version of the OpenAPI document: 0.0.5.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * @type AccountTokenTupleInner
 * @export
 */
export type AccountTokenTupleInner = Party | Token;

/**
 * @type Action
 * A contract which becomes active when an action occurs.
 * @export
 */
export type Action = ChoiceAction | DepositAction | NotifyAction;

/**
 * @type ActionObject
 * A contract which becomes active when an action occurs.
 * @export
 */
export type ActionObject = ChoiceActionObject | DepositActionObject | LabelRef | NotifyActionObject;

/**
 * 
 * @export
 * @interface Add
 */
export interface Add {
    /**
     * 
     * @type {Value}
     * @memberof Add
     */
    'add': Value;
    /**
     * 
     * @type {Value}
     * @memberof Add
     */
    'and': Value;
}
/**
 * 
 * @export
 * @interface AddObject
 */
export interface AddObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof AddObject
     */
    'add': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof AddObject
     */
    'and': ValueObject;
}
/**
 * 
 * @export
 * @interface AddressAndMetadata
 */
export interface AddressAndMetadata {
    /**
     * A cardano address, in Bech32 format
     * @type {string}
     * @memberof AddressAndMetadata
     */
    'address': string;
    /**
     * 
     * @type {TokenMetadata}
     * @memberof AddressAndMetadata
     */
    'metadata'?: TokenMetadata;
}
/**
 * 
 * @export
 * @interface And
 */
export interface And {
    /**
     * 
     * @type {Observation}
     * @memberof And
     */
    'and': Observation;
    /**
     * 
     * @type {Observation}
     * @memberof And
     */
    'both': Observation;
}
/**
 * 
 * @export
 * @interface AndObject
 */
export interface AndObject {
    /**
     * 
     * @type {ObservationObject}
     * @memberof AndObject
     */
    'and': ObservationObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof AndObject
     */
    'both': ObservationObject;
}
/**
 * Applicable Inputs for a given contract
 * @export
 * @interface ApplicableInputs
 */
export interface ApplicableInputs {
    /**
     * 
     * @type {Array<CanChoose>}
     * @memberof ApplicableInputs
     */
    'choices': Array<CanChoose>;
    /**
     * 
     * @type {Array<CanDeposit>}
     * @memberof ApplicableInputs
     */
    'deposits': Array<CanDeposit>;
    /**
     * 
     * @type {CanNotify}
     * @memberof ApplicableInputs
     */
    'notify'?: CanNotify;
}
/**
 * 
 * @export
 * @interface ApplyInputsResponse
 */
export interface ApplyInputsResponse {
    /**
     * 
     * @type {ApplyInputsResponseLinks}
     * @memberof ApplyInputsResponse
     */
    'links': ApplyInputsResponseLinks;
    /**
     * 
     * @type {ApplyInputsTxEnvelope}
     * @memberof ApplyInputsResponse
     */
    'resource': ApplyInputsTxEnvelope;
}
/**
 * 
 * @export
 * @interface ApplyInputsResponseLinks
 */
export interface ApplyInputsResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof ApplyInputsResponseLinks
     */
    'transaction'?: string;
}
/**
 * The \"type\" property of \"tx\" must be \"Tx BabbageEra\" or \"Tx ConwayEra\"
 * @export
 * @interface ApplyInputsTxEnvelope
 */
export interface ApplyInputsTxEnvelope {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ApplyInputsTxEnvelope
     */
    'contractId': string;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof ApplyInputsTxEnvelope
     */
    'transactionId': string;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof ApplyInputsTxEnvelope
     */
    'tx': TextEnvelope;
}
/**
 * Check an observation and produce a warning if it is false.
 * @export
 * @interface Assert
 */
export interface Assert {
    /**
     * 
     * @type {Observation}
     * @memberof Assert
     */
    'assert': Observation;
    /**
     * 
     * @type {Contract}
     * @memberof Assert
     */
    'then': Contract;
}
/**
 * A semantics assertion failed.
 * @export
 * @enum {string}
 */

export const AssertFail = {
    AssertionFailed: 'assertion_failed'
} as const;

export type AssertFail = typeof AssertFail[keyof typeof AssertFail];


/**
 * Check an observation and produce a warning if it is false.
 * @export
 * @interface AssertObject
 */
export interface AssertObject {
    /**
     * 
     * @type {ObservationObject}
     * @memberof AssertObject
     */
    'assert': ObservationObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof AssertObject
     */
    'then': ContractObject;
}
/**
 * 
 * @export
 * @interface AssetId
 */
export interface AssetId {
    /**
     * 
     * @type {string}
     * @memberof AssetId
     */
    'assetName': string;
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof AssetId
     */
    'policyId': string;
}
/**
 * 
 * @export
 * @interface Assets
 */
export interface Assets {
    /**
     * 
     * @type {number}
     * @memberof Assets
     */
    'lovelace': number;
    /**
     * 
     * @type {{ [key: string]: { [key: string]: number | undefined; } | undefined; }}
     * @memberof Assets
     */
    'tokens': { [key: string]: { [key: string]: number | undefined; } | undefined; };
}
/**
 * 
 * @export
 * @interface BlockHeader
 */
export interface BlockHeader {
    /**
     * 
     * @type {string}
     * @memberof BlockHeader
     */
    'blockHeaderHash': string;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    'blockNo': number;
    /**
     * 
     * @type {number}
     * @memberof BlockHeader
     */
    'slotNo': number;
}
/**
 * An inclusive range of values for a choice.
 * @export
 * @interface Bound
 */
export interface Bound {
    /**
     * 
     * @type {number}
     * @memberof Bound
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof Bound
     */
    'to': number;
}
/**
 * Choice Inputs that can be applied for a given contract
 * @export
 * @interface CanChoose
 */
export interface CanChoose {
    /**
     * 
     * @type {Array<Bound>}
     * @memberof CanChoose
     */
    'can_choose_between': Array<Bound>;
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanChoose
     */
    'case_index': number;
    /**
     * 
     * @type {ChoiceId}
     * @memberof CanChoose
     */
    'for_choice': ChoiceId;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanChoose
     */
    'is_merkleized_continuation': boolean;
}
/**
 * Deposit Input that can be applied for a given contract
 * @export
 * @interface CanDeposit
 */
export interface CanDeposit {
    /**
     * 
     * @type {number}
     * @memberof CanDeposit
     */
    'can_deposit': number;
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanDeposit
     */
    'case_index': number;
    /**
     * 
     * @type {Party}
     * @memberof CanDeposit
     */
    'into_account': Party;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanDeposit
     */
    'is_merkleized_continuation': boolean;
    /**
     * 
     * @type {Token}
     * @memberof CanDeposit
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof CanDeposit
     */
    'party': Party;
}
/**
 * Notify Input tha can be applied for a given contract
 * @export
 * @interface CanNotify
 */
export interface CanNotify {
    /**
     * Index of a \"Case Action\" in a \"When\"
     * @type {number}
     * @memberof CanNotify
     */
    'case_index': number;
    /**
     * Indicates if a given contract continuation is merkleized
     * @type {boolean}
     * @memberof CanNotify
     */
    'is_merkleized_continuation': boolean;
}
/**
 * @type Case
 * A contract which becomes active when an action occurs.
 * @export
 */
export type Case = CaseMerkleizedThen | CaseThen;

/**
 * 
 * @export
 * @interface CaseMerkleizedThen
 */
export interface CaseMerkleizedThen {
    /**
     * 
     * @type {Action}
     * @memberof CaseMerkleizedThen
     */
    'case': Action;
    /**
     * 
     * @type {string}
     * @memberof CaseMerkleizedThen
     */
    'merkleized_then': string;
}
/**
 * 
 * @export
 * @interface CaseMerkleizedThenObject
 */
export interface CaseMerkleizedThenObject {
    /**
     * 
     * @type {ActionObject}
     * @memberof CaseMerkleizedThenObject
     */
    'case': ActionObject;
    /**
     * 
     * @type {string}
     * @memberof CaseMerkleizedThenObject
     */
    'merkleized_then': string;
}
/**
 * @type CaseObject
 * A contract which becomes active when an action occurs.
 * @export
 */
export type CaseObject = CaseMerkleizedThenObject | CaseThenObject;

/**
 * 
 * @export
 * @interface CaseThen
 */
export interface CaseThen {
    /**
     * 
     * @type {Action}
     * @memberof CaseThen
     */
    'case': Action;
    /**
     * 
     * @type {Contract}
     * @memberof CaseThen
     */
    'then': Contract;
}
/**
 * 
 * @export
 * @interface CaseThenObject
 */
export interface CaseThenObject {
    /**
     * 
     * @type {ActionObject}
     * @memberof CaseThenObject
     */
    'case': ActionObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof CaseThenObject
     */
    'then': ContractObject;
}
/**
 * 
 * @export
 * @interface ChoiceAction
 */
export interface ChoiceAction {
    /**
     * 
     * @type {Array<Bound>}
     * @memberof ChoiceAction
     */
    'choose_between': Array<Bound>;
    /**
     * 
     * @type {ChoiceId}
     * @memberof ChoiceAction
     */
    'for_choice': ChoiceId;
}
/**
 * 
 * @export
 * @interface ChoiceActionObject
 */
export interface ChoiceActionObject {
    /**
     * 
     * @type {Array<Bound>}
     * @memberof ChoiceActionObject
     */
    'choose_between': Array<Bound>;
    /**
     * 
     * @type {ChoiceId}
     * @memberof ChoiceActionObject
     */
    'for_choice': ChoiceId;
}
/**
 * Make a choice in a contract and provide the continuation of the contract
 * @export
 * @interface ChoiceContinuationInput
 */
export interface ChoiceContinuationInput {
    /**
     * 
     * @type {string}
     * @memberof ChoiceContinuationInput
     */
    'continuation_hash': string;
    /**
     * 
     * @type {ChoiceId}
     * @memberof ChoiceContinuationInput
     */
    'for_choice_id': ChoiceId;
    /**
     * 
     * @type {number}
     * @memberof ChoiceContinuationInput
     */
    'input_that_chooses_num': number;
    /**
     * 
     * @type {Contract}
     * @memberof ChoiceContinuationInput
     */
    'merkleized_continuation': Contract;
}
/**
 * Refers to a party by role name.
 * @export
 * @interface ChoiceId
 */
export interface ChoiceId {
    /**
     * 
     * @type {string}
     * @memberof ChoiceId
     */
    'choice_name': string;
    /**
     * 
     * @type {Party}
     * @memberof ChoiceId
     */
    'choice_owner': Party;
}
/**
 * Refers to a party by role name.
 * @export
 * @interface ChoiceIdObject
 */
export interface ChoiceIdObject {
    /**
     * 
     * @type {string}
     * @memberof ChoiceIdObject
     */
    'choice_name': string;
    /**
     * 
     * @type {PartyObject}
     * @memberof ChoiceIdObject
     */
    'choice_owner': PartyObject;
}
/**
 * Make a choice in a contract
 * @export
 * @interface ChoiceInput
 */
export interface ChoiceInput {
    /**
     * 
     * @type {ChoiceId}
     * @memberof ChoiceInput
     */
    'for_choice_id': ChoiceId;
    /**
     * 
     * @type {number}
     * @memberof ChoiceInput
     */
    'input_that_chooses_num': number;
}
/**
 * 
 * @export
 * @interface ChooseFor
 */
export interface ChooseFor {
    /**
     * 
     * @type {ChoiceId}
     * @memberof ChooseFor
     */
    'chose_something_for': ChoiceId;
}
/**
 * 
 * @export
 * @interface ChooseForObject
 */
export interface ChooseForObject {
    /**
     * 
     * @type {ChoiceIdObject}
     * @memberof ChooseForObject
     */
    'chose_something_for': ChoiceIdObject;
}
/**
 * No more payments will be sent and the balance of the contract is 0.
 * @export
 * @enum {string}
 */

export const Close = {
    Close: 'close'
} as const;

export type Close = typeof Close[keyof typeof Close];


/**
 * No more payments will be sent and the balance of the contract is 0.
 * @export
 * @enum {string}
 */

export const CloseObject = {
    Close: 'close'
} as const;

export type CloseObject = typeof CloseObject[keyof typeof CloseObject];


/**
 * Notify a contract to check a condition and provide the continuation of the contract
 * @export
 * @interface ContinuationInput
 */
export interface ContinuationInput {
    /**
     * 
     * @type {string}
     * @memberof ContinuationInput
     */
    'continuation_hash': string;
    /**
     * 
     * @type {Contract}
     * @memberof ContinuationInput
     */
    'merkleized_continuation': Contract;
}
/**
 * @type Contract
 * Contract terms specified in Marlowe
 * @export
 */
export type Contract = Assert | Close | If | Let | Pay | When;

/**
 * 
 * @export
 * @interface ContractHeader
 */
export interface ContractHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof ContractHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof ContractHeader
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractHeader
     */
    'contractId': string;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof ContractHeader
     */
    'metadata': { [key: string]: Metadata | undefined; };
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof ContractHeader
     */
    'roleTokenMintingPolicyId': string;
    /**
     * 
     * @type {TxStatus}
     * @memberof ContractHeader
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof ContractHeader
     */
    'tags': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof ContractHeader
     */
    'version': MarloweVersion;
}


/**
 * @type ContractObject
 * Contract terms specified in Marlowe
 * @export
 */
export type ContractObject = AssertObject | CloseObject | IfObject | LabelRef | LetObject | PayObject | WhenObject;

/**
 * 
 * @export
 * @interface ContractSourceIds
 */
export interface ContractSourceIds {
    /**
     * 
     * @type {Array<string>}
     * @memberof ContractSourceIds
     */
    'results': Array<string>;
}
/**
 * 
 * @export
 * @interface ContractState
 */
export interface ContractState {
    /**
     * 
     * @type {Assets}
     * @memberof ContractState
     */
    'assets': Assets;
    /**
     * 
     * @type {BlockHeader}
     * @memberof ContractState
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof ContractState
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractState
     */
    'contractId': string;
    /**
     * 
     * @type {Contract}
     * @memberof ContractState
     */
    'currentContract'?: Contract;
    /**
     * 
     * @type {Contract}
     * @memberof ContractState
     */
    'initialContract': Contract;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof ContractState
     */
    'metadata': { [key: string]: Metadata | undefined; };
    /**
     * The hex-encoded minting policy ID for a native Cardano token
     * @type {string}
     * @memberof ContractState
     */
    'roleTokenMintingPolicyId': string;
    /**
     * 
     * @type {MarloweState}
     * @memberof ContractState
     */
    'state'?: MarloweState;
    /**
     * 
     * @type {TxStatus}
     * @memberof ContractState
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof ContractState
     */
    'tags': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {TextEnvelope}
     * @memberof ContractState
     */
    'txBody'?: TextEnvelope;
    /**
     * 
     * @type {Array<Payout>}
     * @memberof ContractState
     */
    'unclaimedPayouts': Array<Payout>;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof ContractState
     */
    'utxo'?: string;
    /**
     * 
     * @type {MarloweVersion}
     * @memberof ContractState
     */
    'version': MarloweVersion;
}


/**
 * 
 * @export
 * @interface CreateContractResponse
 */
export interface CreateContractResponse {
    /**
     * 
     * @type {CreateContractResponseLinks}
     * @memberof CreateContractResponse
     */
    'links': CreateContractResponseLinks;
    /**
     * 
     * @type {CreateTxEnvelope}
     * @memberof CreateContractResponse
     */
    'resource': CreateTxEnvelope;
}
/**
 * 
 * @export
 * @interface CreateContractResponseLinks
 */
export interface CreateContractResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof CreateContractResponseLinks
     */
    'contract'?: string;
}
/**
 * The \"type\" property of \"txBody\" must be \"TxBody BabbageEra\" or \"TxBody ConwayEra\"
 * @export
 * @interface CreateTxBodyEnvelope
 */
export interface CreateTxBodyEnvelope {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof CreateTxBodyEnvelope
     */
    'contractId': string;
    /**
     * 
     * @type {Array<SafetyError>}
     * @memberof CreateTxBodyEnvelope
     */
    'safetyErrors'?: Array<SafetyError>;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof CreateTxBodyEnvelope
     */
    'txBody': TextEnvelope;
}
/**
 * The \"type\" property of \"tx\" must be \"Tx BabbageEra\" or \"Tx ConwayEra\"
 * @export
 * @interface CreateTxEnvelope
 */
export interface CreateTxEnvelope {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof CreateTxEnvelope
     */
    'contractId': string;
    /**
     * 
     * @type {Array<SafetyError>}
     * @memberof CreateTxEnvelope
     */
    'safetyErrors'?: Array<SafetyError>;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof CreateTxEnvelope
     */
    'tx': TextEnvelope;
}
/**
 * 
 * @export
 * @interface DepositAction
 */
export interface DepositAction {
    /**
     * 
     * @type {Value}
     * @memberof DepositAction
     */
    'deposits': Value;
    /**
     * 
     * @type {Party}
     * @memberof DepositAction
     */
    'into_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof DepositAction
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof DepositAction
     */
    'party': Party;
}
/**
 * 
 * @export
 * @interface DepositActionObject
 */
export interface DepositActionObject {
    /**
     * 
     * @type {Value}
     * @memberof DepositActionObject
     */
    'deposits': Value;
    /**
     * 
     * @type {Party}
     * @memberof DepositActionObject
     */
    'into_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof DepositActionObject
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof DepositActionObject
     */
    'party': Party;
}
/**
 * Deposit funds into an account in a contract and provide the continuation of the contract
 * @export
 * @interface DepositContinuationInput
 */
export interface DepositContinuationInput {
    /**
     * 
     * @type {string}
     * @memberof DepositContinuationInput
     */
    'continuation_hash': string;
    /**
     * 
     * @type {Party}
     * @memberof DepositContinuationInput
     */
    'input_from_party': Party;
    /**
     * 
     * @type {Party}
     * @memberof DepositContinuationInput
     */
    'into_account': Party;
    /**
     * 
     * @type {Contract}
     * @memberof DepositContinuationInput
     */
    'merkleized_continuation': Contract;
    /**
     * 
     * @type {Token}
     * @memberof DepositContinuationInput
     */
    'of_token': Token;
    /**
     * 
     * @type {number}
     * @memberof DepositContinuationInput
     */
    'that_deposits': number;
}
/**
 * Deposit funds into an account in a contract
 * @export
 * @interface DepositInput
 */
export interface DepositInput {
    /**
     * 
     * @type {Party}
     * @memberof DepositInput
     */
    'input_from_party': Party;
    /**
     * 
     * @type {Party}
     * @memberof DepositInput
     */
    'into_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof DepositInput
     */
    'of_token': Token;
    /**
     * 
     * @type {number}
     * @memberof DepositInput
     */
    'that_deposits': number;
}
/**
 * 
 * @export
 * @interface Divide
 */
export interface Divide {
    /**
     * 
     * @type {Value}
     * @memberof Divide
     */
    'by': Value;
    /**
     * 
     * @type {Value}
     * @memberof Divide
     */
    'divide': Value;
}
/**
 * 
 * @export
 * @interface DivideObject
 */
export interface DivideObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof DivideObject
     */
    'by': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof DivideObject
     */
    'divide': ValueObject;
}
/**
 * 
 * @export
 * @interface Equal
 */
export interface Equal {
    /**
     * 
     * @type {Value}
     * @memberof Equal
     */
    'equal_to': Value;
    /**
     * 
     * @type {Value}
     * @memberof Equal
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface EqualObject
 */
export interface EqualObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof EqualObject
     */
    'equal_to': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof EqualObject
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface ExBudget
 */
export interface ExBudget {
    /**
     * 
     * @type {number}
     * @memberof ExBudget
     */
    'exBudgetCPU': number;
    /**
     * 
     * @type {number}
     * @memberof ExBudget
     */
    'exBudgetMemory': number;
}
/**
 * 
 * @export
 * @interface GetContractResponse
 */
export interface GetContractResponse {
    /**
     * 
     * @type {GetContractResponseLinks}
     * @memberof GetContractResponse
     */
    'links': GetContractResponseLinks;
    /**
     * 
     * @type {ContractState}
     * @memberof GetContractResponse
     */
    'resource': ContractState;
}
/**
 * 
 * @export
 * @interface GetContractResponseLinks
 */
export interface GetContractResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof GetContractResponseLinks
     */
    'transactions'?: string;
}
/**
 * 
 * @export
 * @interface GetContractsResponse
 */
export interface GetContractsResponse {
    /**
     * 
     * @type {Array<GetContractsResponseResultsInner>}
     * @memberof GetContractsResponse
     */
    'results': Array<GetContractsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetContractsResponseResultsInner
 */
export interface GetContractsResponseResultsInner {
    /**
     * 
     * @type {GetContractsResponseResultsInnerLinks}
     * @memberof GetContractsResponseResultsInner
     */
    'links': GetContractsResponseResultsInnerLinks;
    /**
     * 
     * @type {ContractHeader}
     * @memberof GetContractsResponseResultsInner
     */
    'resource': ContractHeader;
}
/**
 * 
 * @export
 * @interface GetContractsResponseResultsInnerLinks
 */
export interface GetContractsResponseResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof GetContractsResponseResultsInnerLinks
     */
    'contract'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetContractsResponseResultsInnerLinks
     */
    'transactions'?: string;
}
/**
 * 
 * @export
 * @interface GetPayoutResponse
 */
export interface GetPayoutResponse {
    /**
     * 
     * @type {GetPayoutResponseLinks}
     * @memberof GetPayoutResponse
     */
    'links': GetPayoutResponseLinks;
    /**
     * 
     * @type {PayoutState}
     * @memberof GetPayoutResponse
     */
    'resource': PayoutState;
}
/**
 * 
 * @export
 * @interface GetPayoutResponseLinks
 */
export interface GetPayoutResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof GetPayoutResponseLinks
     */
    'contract'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPayoutResponseLinks
     */
    'transaction'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetPayoutResponseLinks
     */
    'withdrawal'?: string;
}
/**
 * 
 * @export
 * @interface GetPayoutsResponse
 */
export interface GetPayoutsResponse {
    /**
     * 
     * @type {Array<GetPayoutsResponseResultsInner>}
     * @memberof GetPayoutsResponse
     */
    'results': Array<GetPayoutsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetPayoutsResponseResultsInner
 */
export interface GetPayoutsResponseResultsInner {
    /**
     * 
     * @type {GetPayoutsResponseResultsInnerLinks}
     * @memberof GetPayoutsResponseResultsInner
     */
    'links': GetPayoutsResponseResultsInnerLinks;
    /**
     * 
     * @type {PayoutHeader}
     * @memberof GetPayoutsResponseResultsInner
     */
    'resource': PayoutHeader;
}
/**
 * 
 * @export
 * @interface GetPayoutsResponseResultsInnerLinks
 */
export interface GetPayoutsResponseResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof GetPayoutsResponseResultsInnerLinks
     */
    'payout'?: string;
}
/**
 * 
 * @export
 * @interface GetTransactionResponse
 */
export interface GetTransactionResponse {
    /**
     * 
     * @type {GetTransactionResponseLinks}
     * @memberof GetTransactionResponse
     */
    'links': GetTransactionResponseLinks;
    /**
     * 
     * @type {Tx}
     * @memberof GetTransactionResponse
     */
    'resource': Tx;
}
/**
 * 
 * @export
 * @interface GetTransactionResponseLinks
 */
export interface GetTransactionResponseLinks {
    /**
     * 
     * @type {string}
     * @memberof GetTransactionResponseLinks
     */
    'next'?: string;
    /**
     * 
     * @type {string}
     * @memberof GetTransactionResponseLinks
     */
    'previous'?: string;
}
/**
 * 
 * @export
 * @interface GetTransactionsResponse
 */
export interface GetTransactionsResponse {
    /**
     * 
     * @type {Array<GetTransactionsResponseResultsInner>}
     * @memberof GetTransactionsResponse
     */
    'results': Array<GetTransactionsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetTransactionsResponseResultsInner
 */
export interface GetTransactionsResponseResultsInner {
    /**
     * 
     * @type {ApplyInputsResponseLinks}
     * @memberof GetTransactionsResponseResultsInner
     */
    'links': ApplyInputsResponseLinks;
    /**
     * 
     * @type {TxHeader}
     * @memberof GetTransactionsResponseResultsInner
     */
    'resource': TxHeader;
}
/**
 * 
 * @export
 * @interface GetWithdrawalsResponse
 */
export interface GetWithdrawalsResponse {
    /**
     * 
     * @type {Array<GetWithdrawalsResponseResultsInner>}
     * @memberof GetWithdrawalsResponse
     */
    'results': Array<GetWithdrawalsResponseResultsInner>;
}
/**
 * 
 * @export
 * @interface GetWithdrawalsResponseResultsInner
 */
export interface GetWithdrawalsResponseResultsInner {
    /**
     * 
     * @type {GetWithdrawalsResponseResultsInnerLinks}
     * @memberof GetWithdrawalsResponseResultsInner
     */
    'links': GetWithdrawalsResponseResultsInnerLinks;
    /**
     * 
     * @type {WithdrawalHeader}
     * @memberof GetWithdrawalsResponseResultsInner
     */
    'resource': WithdrawalHeader;
}
/**
 * 
 * @export
 * @interface GetWithdrawalsResponseResultsInnerLinks
 */
export interface GetWithdrawalsResponseResultsInnerLinks {
    /**
     * 
     * @type {string}
     * @memberof GetWithdrawalsResponseResultsInnerLinks
     */
    'withdrawal'?: string;
}
/**
 * 
 * @export
 * @interface Greater
 */
export interface Greater {
    /**
     * 
     * @type {Value}
     * @memberof Greater
     */
    'gt': Value;
    /**
     * 
     * @type {Value}
     * @memberof Greater
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface GreaterObject
 */
export interface GreaterObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof GreaterObject
     */
    'gt': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof GreaterObject
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface GreaterOrEqual
 */
export interface GreaterOrEqual {
    /**
     * 
     * @type {Value}
     * @memberof GreaterOrEqual
     */
    'ge_than': Value;
    /**
     * 
     * @type {Value}
     * @memberof GreaterOrEqual
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface GreaterOrEqualObject
 */
export interface GreaterOrEqualObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof GreaterOrEqualObject
     */
    'ge_than': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof GreaterOrEqualObject
     */
    'value': ValueObject;
}
/**
 * If an observation is true, the first contract applies, otherwise the second contract applies.
 * @export
 * @interface If
 */
export interface If {
    /**
     * 
     * @type {Contract}
     * @memberof If
     */
    'else': Contract;
    /**
     * 
     * @type {Observation}
     * @memberof If
     */
    'if': Observation;
    /**
     * 
     * @type {Contract}
     * @memberof If
     */
    'then': Contract;
}
/**
 * If an observation is true, the first contract applies, otherwise the second contract applies.
 * @export
 * @interface IfObject
 */
export interface IfObject {
    /**
     * 
     * @type {ContractObject}
     * @memberof IfObject
     */
    'else': ContractObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof IfObject
     */
    'if': ObservationObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof IfObject
     */
    'then': ContractObject;
}
/**
 * 
 * @export
 * @interface IfValue
 */
export interface IfValue {
    /**
     * 
     * @type {Value}
     * @memberof IfValue
     */
    'else': Value;
    /**
     * 
     * @type {Observation}
     * @memberof IfValue
     */
    'if': Observation;
    /**
     * 
     * @type {Value}
     * @memberof IfValue
     */
    'then': Value;
}
/**
 * 
 * @export
 * @interface IfValueObject
 */
export interface IfValueObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof IfValueObject
     */
    'else': ValueObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof IfValueObject
     */
    'if': ObservationObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof IfValueObject
     */
    'then': ValueObject;
}
/**
 * @type Input
 * An input to a Marlowe transaction
 * @export
 */
export type Input = ChoiceContinuationInput | ChoiceInput | ContinuationInput | DepositContinuationInput | DepositInput | NotifyInput;

/**
 * @type IntervalError
 * A Marlowe transaction interval error.
 * @export
 */
export type IntervalError = IntervalInPast | InvalidInterval;

/**
 * Marlowe transaction interval in past.
 * @export
 * @interface IntervalInPast
 */
export interface IntervalInPast {
    /**
     * 
     * @type {IntervalInPastIntervalInPastError}
     * @memberof IntervalInPast
     */
    'intervalInPastError': IntervalInPastIntervalInPastError;
}
/**
 * 
 * @export
 * @interface IntervalInPastIntervalInPastError
 */
export interface IntervalInPastIntervalInPastError {
    /**
     * 
     * @type {number}
     * @memberof IntervalInPastIntervalInPastError
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalInPastIntervalInPastError
     */
    'minTime': number;
    /**
     * 
     * @type {number}
     * @memberof IntervalInPastIntervalInPastError
     */
    'to': number;
}
/**
 * Invalid Marlowe transaction interval.
 * @export
 * @interface InvalidInterval
 */
export interface InvalidInterval {
    /**
     * 
     * @type {InvalidIntervalInvalidInterval}
     * @memberof InvalidInterval
     */
    'invalidInterval': InvalidIntervalInvalidInterval;
}
/**
 * 
 * @export
 * @interface InvalidIntervalInvalidInterval
 */
export interface InvalidIntervalInvalidInterval {
    /**
     * 
     * @type {number}
     * @memberof InvalidIntervalInvalidInterval
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof InvalidIntervalInvalidInterval
     */
    'to': number;
}
/**
 * 
 * @export
 * @interface LabelRef
 */
export interface LabelRef {
    /**
     * An arbitrary text identifier for an object in a Marlowe object bundle.
     * @type {string}
     * @memberof LabelRef
     */
    'ref': string;
}
/**
 * A bundle of labelled Marlowe objects in define-before-use order.
 * @export
 * @interface LabelledObject
 */
export interface LabelledObject {
    /**
     * An arbitrary text identifier for an object in a Marlowe object bundle.
     * @type {string}
     * @memberof LabelledObject
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof LabelledObject
     */
    'type': LabelledObjectTypeEnum;
    /**
     * 
     * @type {LabelledObjectValue}
     * @memberof LabelledObject
     */
    'value': LabelledObjectValue;
}

export const LabelledObjectTypeEnum = {
    Value: 'value',
    Observation: 'observation',
    Contract: 'contract',
    Party: 'party',
    Token: 'token',
    Action: 'action'
} as const;

export type LabelledObjectTypeEnum = typeof LabelledObjectTypeEnum[keyof typeof LabelledObjectTypeEnum];

/**
 * @type LabelledObjectValue
 * @export
 */
export type LabelledObjectValue = ActionObject | ContractObject | ObservationObject | PartyObject | TokenObject | ValueObject;

/**
 * 
 * @export
 * @interface Lesser
 */
export interface Lesser {
    /**
     * 
     * @type {Value}
     * @memberof Lesser
     */
    'lt': Value;
    /**
     * 
     * @type {Value}
     * @memberof Lesser
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface LesserObject
 */
export interface LesserObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof LesserObject
     */
    'lt': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof LesserObject
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface LesserOrEqual
 */
export interface LesserOrEqual {
    /**
     * 
     * @type {Value}
     * @memberof LesserOrEqual
     */
    'le_than': Value;
    /**
     * 
     * @type {Value}
     * @memberof LesserOrEqual
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface LesserOrEqualObject
 */
export interface LesserOrEqualObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof LesserOrEqualObject
     */
    'le_than': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof LesserOrEqualObject
     */
    'value': ValueObject;
}
/**
 * Bind a value to a name within the scope of a sub-contract.
 * @export
 * @interface Let
 */
export interface Let {
    /**
     * 
     * @type {Value}
     * @memberof Let
     */
    'be': Value;
    /**
     * 
     * @type {string}
     * @memberof Let
     */
    'let': string;
    /**
     * 
     * @type {Contract}
     * @memberof Let
     */
    'then': Contract;
}
/**
 * Bind a value to a name within the scope of a sub-contract.
 * @export
 * @interface LetObject
 */
export interface LetObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof LetObject
     */
    'be': ValueObject;
    /**
     * 
     * @type {string}
     * @memberof LetObject
     */
    'let': string;
    /**
     * 
     * @type {ContractObject}
     * @memberof LetObject
     */
    'then': ContractObject;
}
/**
 * The on-chain state of a Marlowe contract.
 * @export
 * @interface MarloweState
 */
export interface MarloweState {
    /**
     * 
     * @type {Array<Array<MarloweStateAccountsInnerInner>>}
     * @memberof MarloweState
     */
    'accounts': Array<Array<MarloweStateAccountsInnerInner>>;
    /**
     * 
     * @type {Array<Array<MarloweStateBoundValuesInnerInner>>}
     * @memberof MarloweState
     */
    'boundValues': Array<Array<MarloweStateBoundValuesInnerInner>>;
    /**
     * 
     * @type {Array<Array<MarloweStateChoicesInnerInner>>}
     * @memberof MarloweState
     */
    'choices': Array<Array<MarloweStateChoicesInnerInner>>;
    /**
     * 
     * @type {number}
     * @memberof MarloweState
     */
    'minTime': number;
}
/**
 * @type MarloweStateAccountsInnerInner
 * @export
 */
export type MarloweStateAccountsInnerInner = Array<AccountTokenTupleInner> | number;

/**
 * @type MarloweStateBoundValuesInnerInner
 * @export
 */
export type MarloweStateBoundValuesInnerInner = number | string;

/**
 * @type MarloweStateChoicesInnerInner
 * @export
 */
export type MarloweStateChoicesInnerInner = ChoiceId | number;

/**
 * A version of the Marlowe language.
 * @export
 * @enum {string}
 */

export const MarloweVersion = {
    V1: 'v1'
} as const;

export type MarloweVersion = typeof MarloweVersion[keyof typeof MarloweVersion];


/**
 * @type Metadata
 * Arbitrary JSON-encoded transaction metadata
 * @export
 */
export type Metadata = Array<Metadata> | number | string | { [key: string]: Metadata | undefined; };

/**
 * 
 * @export
 * @interface MetadataAndRecipients
 */
export interface MetadataAndRecipients {
    /**
     * 
     * @type {TokenMetadata}
     * @memberof MetadataAndRecipients
     */
    'metadata'?: TokenMetadata;
    /**
     * 
     * @type {{ [key: string]: number | undefined; }}
     * @memberof MetadataAndRecipients
     */
    'recipients': { [key: string]: number | undefined; };
}
/**
 * 
 * @export
 * @interface MetadataAndScript
 */
export interface MetadataAndScript {
    /**
     * 
     * @type {TokenMetadata}
     * @memberof MetadataAndScript
     */
    'metadata'?: TokenMetadata;
    /**
     * The type of script receiving the role token.
     * @type {string}
     * @memberof MetadataAndScript
     */
    'script': MetadataAndScriptScriptEnum;
}

export const MetadataAndScriptScriptEnum = {
    OpenRole: 'OpenRole'
} as const;

export type MetadataAndScriptScriptEnum = typeof MetadataAndScriptScriptEnum[keyof typeof MetadataAndScriptScriptEnum];

/**
 * 
 * @export
 * @interface Minus
 */
export interface Minus {
    /**
     * 
     * @type {Value}
     * @memberof Minus
     */
    'minus': Value;
    /**
     * 
     * @type {Value}
     * @memberof Minus
     */
    'value': Value;
}
/**
 * 
 * @export
 * @interface MinusObject
 */
export interface MinusObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof MinusObject
     */
    'minus': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof MinusObject
     */
    'value': ValueObject;
}
/**
 * 
 * @export
 * @interface Multiply
 */
export interface Multiply {
    /**
     * 
     * @type {Value}
     * @memberof Multiply
     */
    'multiply': Value;
    /**
     * 
     * @type {Value}
     * @memberof Multiply
     */
    'times': Value;
}
/**
 * 
 * @export
 * @interface MultiplyObject
 */
export interface MultiplyObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof MultiplyObject
     */
    'multiply': ValueObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof MultiplyObject
     */
    'times': ValueObject;
}
/**
 * 
 * @export
 * @interface Negate
 */
export interface Negate {
    /**
     * 
     * @type {Value}
     * @memberof Negate
     */
    'negate': Value;
}
/**
 * 
 * @export
 * @interface NegateObject
 */
export interface NegateObject {
    /**
     * 
     * @type {ValueObject}
     * @memberof NegateObject
     */
    'negate': ValueObject;
}
/**
 * Describe the reducibility (Can be Reduced ?) and the applicability (Can Inputs be Applied ?) for a given contract.
 * @export
 * @interface Next
 */
export interface Next {
    /**
     * 
     * @type {ApplicableInputs}
     * @memberof Next
     */
    'applicable_inputs': ApplicableInputs;
    /**
     * Indicates if a given contract can be reduced (apply []) or not.
     * @type {boolean}
     * @memberof Next
     */
    'can_reduce': boolean;
}
/**
 * A warning for a non-positive deposit.
 * @export
 * @interface NonPositiveDeposit
 */
export interface NonPositiveDeposit {
    /**
     * 
     * @type {number}
     * @memberof NonPositiveDeposit
     */
    'asked_to_deposit': number;
    /**
     * 
     * @type {Party}
     * @memberof NonPositiveDeposit
     */
    'in_account': Party;
    /**
     * 
     * @type {Token}
     * @memberof NonPositiveDeposit
     */
    'of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof NonPositiveDeposit
     */
    'party': Party;
}
/**
 * A warning for a non-positive payment.
 * @export
 * @interface NonPositivePayment
 */
export interface NonPositivePayment {
    /**
     * 
     * @type {Party}
     * @memberof NonPositivePayment
     */
    'account': Party;
    /**
     * 
     * @type {number}
     * @memberof NonPositivePayment
     */
    'asked_to_pay': number;
    /**
     * 
     * @type {Token}
     * @memberof NonPositivePayment
     */
    'of_token': Token;
    /**
     * 
     * @type {Payee}
     * @memberof NonPositivePayment
     */
    'to_payee': Payee;
}
/**
 * 
 * @export
 * @interface Not
 */
export interface Not {
    /**
     * 
     * @type {Observation}
     * @memberof Not
     */
    'not': Observation;
}
/**
 * 
 * @export
 * @interface NotObject
 */
export interface NotObject {
    /**
     * 
     * @type {ObservationObject}
     * @memberof NotObject
     */
    'not': ObservationObject;
}
/**
 * 
 * @export
 * @interface NotifyAction
 */
export interface NotifyAction {
    /**
     * 
     * @type {Observation}
     * @memberof NotifyAction
     */
    'notify_if': Observation;
}
/**
 * 
 * @export
 * @interface NotifyActionObject
 */
export interface NotifyActionObject {
    /**
     * 
     * @type {Observation}
     * @memberof NotifyActionObject
     */
    'notify_if': Observation;
}
/**
 * Notify a contract to check a condition
 * @export
 * @enum {string}
 */

export const NotifyInput = {
    InputNotify: 'input_notify'
} as const;

export type NotifyInput = typeof NotifyInput[keyof typeof NotifyInput];


/**
 * @type Observation
 * A time-varying expression that evaluates to an integer
 * @export
 */
export type Observation = And | ChooseFor | Equal | Greater | GreaterOrEqual | Lesser | LesserOrEqual | Not | Or | boolean;

/**
 * @type ObservationObject
 * A time-varying expression that evaluates to an integer
 * @export
 */
export type ObservationObject = AndObject | ChooseForObject | EqualObject | GreaterObject | GreaterOrEqualObject | LabelRef | LesserObject | LesserOrEqualObject | NotObject | OrObject | boolean;

/**
 * 
 * @export
 * @interface Or
 */
export interface Or {
    /**
     * 
     * @type {Observation}
     * @memberof Or
     */
    'either': Observation;
    /**
     * 
     * @type {Observation}
     * @memberof Or
     */
    'or': Observation;
}
/**
 * 
 * @export
 * @interface OrObject
 */
export interface OrObject {
    /**
     * 
     * @type {ObservationObject}
     * @memberof OrObject
     */
    'either': ObservationObject;
    /**
     * 
     * @type {ObservationObject}
     * @memberof OrObject
     */
    'or': ObservationObject;
}
/**
 * A warning for partial payment.
 * @export
 * @interface PartialPayment
 */
export interface PartialPayment {
    /**
     * 
     * @type {Party}
     * @memberof PartialPayment
     */
    'account': Party;
    /**
     * 
     * @type {number}
     * @memberof PartialPayment
     */
    'asked_to_pay': number;
    /**
     * 
     * @type {number}
     * @memberof PartialPayment
     */
    'but_only_paid': number;
    /**
     * 
     * @type {Token}
     * @memberof PartialPayment
     */
    'of_token': Token;
    /**
     * 
     * @type {Payee}
     * @memberof PartialPayment
     */
    'to_payee': Payee;
}
/**
 * @type Party
 * A participant in a contract
 * @export
 */
export type Party = PartyAddress | PartyRoleName;

/**
 * Refers to a party by Cardano address.
 * @export
 * @interface PartyAddress
 */
export interface PartyAddress {
    /**
     * A cardano address, in Bech32 format
     * @type {string}
     * @memberof PartyAddress
     */
    'address': string;
}
/**
 * @type PartyObject
 * A participant in a contract
 * @export
 */
export type PartyObject = LabelRef | PartyAddress | PartyRoleName;

/**
 * Refers to a party by role name.
 * @export
 * @interface PartyRoleName
 */
export interface PartyRoleName {
    /**
     * 
     * @type {string}
     * @memberof PartyRoleName
     */
    'role_token': string;
}
/**
 * A payment will be sent from an account to a payee.
 * @export
 * @interface Pay
 */
export interface Pay {
    /**
     * 
     * @type {Party}
     * @memberof Pay
     */
    'from_account': Party;
    /**
     * 
     * @type {Value}
     * @memberof Pay
     */
    'pay': Value;
    /**
     * 
     * @type {Contract}
     * @memberof Pay
     */
    'then': Contract;
    /**
     * 
     * @type {Payee}
     * @memberof Pay
     */
    'to': Payee;
    /**
     * 
     * @type {Token}
     * @memberof Pay
     */
    'token': Token;
}
/**
 * A payment will be sent from an account to a payee.
 * @export
 * @interface PayObject
 */
export interface PayObject {
    /**
     * 
     * @type {PartyObject}
     * @memberof PayObject
     */
    'from_account': PartyObject;
    /**
     * 
     * @type {ValueObject}
     * @memberof PayObject
     */
    'pay': ValueObject;
    /**
     * 
     * @type {ContractObject}
     * @memberof PayObject
     */
    'then': ContractObject;
    /**
     * 
     * @type {PayeeObject}
     * @memberof PayObject
     */
    'to': PayeeObject;
    /**
     * 
     * @type {TokenObject}
     * @memberof PayObject
     */
    'token': TokenObject;
}
/**
 * Pays funds into a party\'s account in the contract.
 * @export
 * @interface PayToAccount
 */
export interface PayToAccount {
    /**
     * 
     * @type {Party}
     * @memberof PayToAccount
     */
    'account': Party;
}
/**
 * Pays funds into a party\'s account in the contract.
 * @export
 * @interface PayToAccountObject
 */
export interface PayToAccountObject {
    /**
     * 
     * @type {PartyObject}
     * @memberof PayToAccountObject
     */
    'account': PartyObject;
}
/**
 * Pays funds to a party.
 * @export
 * @interface PayToParty
 */
export interface PayToParty {
    /**
     * 
     * @type {Party}
     * @memberof PayToParty
     */
    'party': Party;
}
/**
 * Pays funds to a party.
 * @export
 * @interface PayToPartyObject
 */
export interface PayToPartyObject {
    /**
     * 
     * @type {PartyObject}
     * @memberof PayToPartyObject
     */
    'party': PartyObject;
}
/**
 * @type Payee
 * A recipient of a payment
 * @export
 */
export type Payee = PayToAccount | PayToParty;

/**
 * @type PayeeObject
 * A recipient of a payment
 * @export
 */
export type PayeeObject = PayToAccountObject | PayToPartyObject;

/**
 * A Marlowe payment.
 * @export
 * @interface Payment
 */
export interface Payment {
    /**
     * 
     * @type {number}
     * @memberof Payment
     */
    'amount': number;
    /**
     * 
     * @type {Party}
     * @memberof Payment
     */
    'payment_from': Party;
    /**
     * 
     * @type {Payee}
     * @memberof Payment
     */
    'to': Payee;
    /**
     * 
     * @type {Token}
     * @memberof Payment
     */
    'token': Token;
}
/**
 * 
 * @export
 * @interface Payout
 */
export interface Payout {
    /**
     * 
     * @type {Assets}
     * @memberof Payout
     */
    'assets': Assets;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Payout
     */
    'payoutId': string;
    /**
     * 
     * @type {string}
     * @memberof Payout
     */
    'role': string;
}
/**
 * 
 * @export
 * @interface PayoutHeader
 */
export interface PayoutHeader {
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutHeader
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutHeader
     */
    'payoutId': string;
    /**
     * 
     * @type {AssetId}
     * @memberof PayoutHeader
     */
    'role': AssetId;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutHeader
     */
    'status': PayoutStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof PayoutHeader
     */
    'withdrawalId'?: string;
}


/**
 * 
 * @export
 * @interface PayoutState
 */
export interface PayoutState {
    /**
     * 
     * @type {Assets}
     * @memberof PayoutState
     */
    'assets': Assets;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutState
     */
    'contractId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof PayoutState
     */
    'payoutId': string;
    /**
     * A cardano address, in Bech32 format
     * @type {string}
     * @memberof PayoutState
     */
    'payoutValidatorAddress': string;
    /**
     * 
     * @type {AssetId}
     * @memberof PayoutState
     */
    'role': AssetId;
    /**
     * 
     * @type {PayoutStatus}
     * @memberof PayoutState
     */
    'status': PayoutStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof PayoutState
     */
    'withdrawalId'?: string;
}


/**
 * The status of a payout. Either it is available to be withdrawn, or it has already been withdrawn.
 * @export
 * @enum {string}
 */

export const PayoutStatus = {
    Available: 'available',
    Withdrawn: 'withdrawn'
} as const;

export type PayoutStatus = typeof PayoutStatus[keyof typeof PayoutStatus];


/**
 * A Plutus address.
 * @export
 * @interface PlutusAddress
 */
export interface PlutusAddress {
    /**
     * 
     * @type {PlutusCredential}
     * @memberof PlutusAddress
     */
    'addressCredential': PlutusCredential;
    /**
     * 
     * @type {PlutusStakingCredential}
     * @memberof PlutusAddress
     */
    'addressStakingCredential'?: PlutusStakingCredential;
}
/**
 * @type PlutusCredential
 * A Plutus credential.
 * @export
 */
export type PlutusCredential = PubKeyCredential | ScriptCredential;

/**
 * @type PlutusStakingCredential
 * A Plutus staking credential.
 * @export
 */
export type PlutusStakingCredential = StakingHash | StakingPointer;

/**
 * 
 * @export
 * @interface PostContractSourceResponse
 */
export interface PostContractSourceResponse {
    /**
     * The hex-encoded identifier of a Marlowe contract source
     * @type {string}
     * @memberof PostContractSourceResponse
     */
    'contractSourceId': string;
    /**
     * 
     * @type {{ [key: string]: string | undefined; }}
     * @memberof PostContractSourceResponse
     */
    'intermediateIds': { [key: string]: string | undefined; };
}
/**
 * 
 * @export
 * @interface PostContractsRequest
 */
export interface PostContractsRequest {
    /**
     * 
     * @type {PostContractsRequestContract}
     * @memberof PostContractsRequest
     */
    'contract': PostContractsRequestContract;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof PostContractsRequest
     */
    'metadata': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {number}
     * @memberof PostContractsRequest
     */
    'minUTxODeposit'?: number;
    /**
     * 
     * @type {RolesConfig}
     * @memberof PostContractsRequest
     */
    'roles'?: RolesConfig;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof PostContractsRequest
     */
    'tags': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {string}
     * @memberof PostContractsRequest
     */
    'threadTokenName'?: string;
    /**
     * 
     * @type {MarloweVersion}
     * @memberof PostContractsRequest
     */
    'version': MarloweVersion;
}


/**
 * @type PostContractsRequestContract
 * @export
 */
export type PostContractsRequestContract = Contract | string;

/**
 * 
 * @export
 * @interface PostTransactionsRequest
 */
export interface PostTransactionsRequest {
    /**
     * 
     * @type {Array<Input>}
     * @memberof PostTransactionsRequest
     */
    'inputs': Array<Input>;
    /**
     * 
     * @type {string}
     * @memberof PostTransactionsRequest
     */
    'invalidBefore'?: string;
    /**
     * 
     * @type {string}
     * @memberof PostTransactionsRequest
     */
    'invalidHereafter'?: string;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof PostTransactionsRequest
     */
    'metadata': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof PostTransactionsRequest
     */
    'tags': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {MarloweVersion}
     * @memberof PostTransactionsRequest
     */
    'version': MarloweVersion;
}


/**
 * 
 * @export
 * @interface PostWithdrawalsRequest
 */
export interface PostWithdrawalsRequest {
    /**
     * 
     * @type {Set<string>}
     * @memberof PostWithdrawalsRequest
     */
    'payouts': Set<string>;
}
/**
 * A Plutus public key credential.
 * @export
 * @interface PubKeyCredential
 */
export interface PubKeyCredential {
    /**
     * 
     * @type {string}
     * @memberof PubKeyCredential
     */
    'pubKeyCredential': string;
}
/**
 * @type RoleTokenConfig
 * @export
 */
export type RoleTokenConfig = AddressAndMetadata | MetadataAndRecipients | MetadataAndScript | string;

/**
 * @type RolesConfig
 * @export
 */
export type RolesConfig = string | { [key: string]: RoleTokenConfig | undefined; };

/**
 * Information about the safety of a Marlowe contract and its state.
 * @export
 * @interface SafetyError
 */
export interface SafetyError {
    /**
     * 
     * @type {Party}
     * @memberof SafetyError
     */
    'account-id'?: Party;
    /**
     * 
     * @type {PlutusAddress}
     * @memberof SafetyError
     */
    'address'?: PlutusAddress;
    /**
     * 
     * @type {number}
     * @memberof SafetyError
     */
    'bytes'?: number;
    /**
     * 
     * @type {ChoiceId}
     * @memberof SafetyError
     */
    'choice-id'?: ChoiceId;
    /**
     * 
     * @type {ExBudget}
     * @memberof SafetyError
     */
    'cost'?: ExBudget;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'currency-symbol'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'detail': string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'error': string;
    /**
     * 
     * @type {boolean}
     * @memberof SafetyError
     */
    'fatal': boolean;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'hash'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'role-name'?: string;
    /**
     * 
     * @type {Token}
     * @memberof SafetyError
     */
    'token'?: Token;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'token-name'?: string;
    /**
     * 
     * @type {Transaction}
     * @memberof SafetyError
     */
    'transaction'?: Transaction;
    /**
     * 
     * @type {string}
     * @memberof SafetyError
     */
    'value-id'?: string;
    /**
     * 
     * @type {TransactionWarning}
     * @memberof SafetyError
     */
    'warning'?: TransactionWarning;
}
/**
 * A Plutus script credential.
 * @export
 * @interface ScriptCredential
 */
export interface ScriptCredential {
    /**
     * 
     * @type {string}
     * @memberof ScriptCredential
     */
    'scriptCredential': string;
}
/**
 * A Plutus staking hash.
 * @export
 * @interface StakingHash
 */
export interface StakingHash {
    /**
     * 
     * @type {PlutusCredential}
     * @memberof StakingHash
     */
    'stakingHash': PlutusCredential;
}
/**
 * A Plutus staking pointer.
 * @export
 * @interface StakingPointer
 */
export interface StakingPointer {
    /**
     * 
     * @type {Array<number>}
     * @memberof StakingPointer
     */
    'stakingHash': Array<number>;
}
/**
 * 
 * @export
 * @interface TextEnvelope
 */
export interface TextEnvelope {
    /**
     * 
     * @type {string}
     * @memberof TextEnvelope
     */
    'cborHex': string;
    /**
     * 
     * @type {string}
     * @memberof TextEnvelope
     */
    'description': string;
    /**
     * What type of data is encoded in the CBOR Hex. Valid values include \"Tx <era>\", \"TxBody <era>\", and \"ShelleyTxWitness <era>\" where <era> is one of \"BabbageEra\", \"ConwayEra\".
     * @type {string}
     * @memberof TextEnvelope
     */
    'type': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const TimeInterval = {
    Start: 'time_interval_start',
    End: 'time_interval_end'
} as const;

export type TimeInterval = typeof TimeInterval[keyof typeof TimeInterval];


/**
 * A token with a currency symbol (minting policy ID) and token name.
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'currency_symbol': string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    'token_name': string;
}
/**
 * 
 * @export
 * @interface TokenInAccount
 */
export interface TokenInAccount {
    /**
     * 
     * @type {Token}
     * @memberof TokenInAccount
     */
    'amount_of_token': Token;
    /**
     * 
     * @type {Party}
     * @memberof TokenInAccount
     */
    'in_account': Party;
}
/**
 * 
 * @export
 * @interface TokenInAccountObject
 */
export interface TokenInAccountObject {
    /**
     * 
     * @type {TokenObject}
     * @memberof TokenInAccountObject
     */
    'amount_of_token': TokenObject;
    /**
     * 
     * @type {PartyObject}
     * @memberof TokenInAccountObject
     */
    'in_account': PartyObject;
}
/**
 * Metadata for an NFT, as described by https://cips.cardano.org/cips/cip25/
 * @export
 * @interface TokenMetadata
 */
export interface TokenMetadata {
    [key: string]: Metadata;

    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'description'?: string;
    /**
     * 
     * @type {Array<TokenMetadataFile>}
     * @memberof TokenMetadata
     */
    'files'?: Array<TokenMetadataFile>;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'mediaType'?: string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadata
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface TokenMetadataFile
 */
export interface TokenMetadataFile {
    [key: string]: Metadata;

    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'mediaType': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof TokenMetadataFile
     */
    'src': string;
}
/**
 * @type TokenObject
 * A token with a currency symbol (minting policy ID) and token name.
 * @export
 */
export type TokenObject = LabelRef | Token;

/**
 * Information about a Marlowe transaction.
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * 
     * @type {Contract}
     * @memberof Transaction
     */
    'contract': Contract;
    /**
     * 
     * @type {TransactionInput}
     * @memberof Transaction
     */
    'input': TransactionInput;
    /**
     * 
     * @type {TransactionOutput}
     * @memberof Transaction
     */
    'output': TransactionOutput;
    /**
     * 
     * @type {MarloweState}
     * @memberof Transaction
     */
    'state': MarloweState;
}
/**
 * @type TransactionError
 * A Marlowe transaction error.
 * @export
 */
export type TransactionError = TransactionErrorOneOf | string;

/**
 * An invalid time interval.
 * @export
 * @interface TransactionErrorOneOf
 */
export interface TransactionErrorOneOf {
    /**
     * 
     * @type {IntervalError}
     * @memberof TransactionErrorOneOf
     */
    'context': IntervalError;
    /**
     * 
     * @type {string}
     * @memberof TransactionErrorOneOf
     */
    'error': TransactionErrorOneOfErrorEnum;
}

export const TransactionErrorOneOfErrorEnum = {
    TeIntervalError: 'TEIntervalError'
} as const;

export type TransactionErrorOneOfErrorEnum = typeof TransactionErrorOneOfErrorEnum[keyof typeof TransactionErrorOneOfErrorEnum];

/**
 * Marlowe transaction input.
 * @export
 * @interface TransactionInput
 */
export interface TransactionInput {
    /**
     * 
     * @type {Array<Input>}
     * @memberof TransactionInput
     */
    'tx_inputs': Array<Input>;
    /**
     * 
     * @type {TransactionInputTxInterval}
     * @memberof TransactionInput
     */
    'tx_interval': TransactionInputTxInterval;
}
/**
 * Time interval.
 * @export
 * @interface TransactionInputTxInterval
 */
export interface TransactionInputTxInterval {
    /**
     * 
     * @type {number}
     * @memberof TransactionInputTxInterval
     */
    'from': number;
    /**
     * 
     * @type {number}
     * @memberof TransactionInputTxInterval
     */
    'to': number;
}
/**
 * @type TransactionOutput
 * Marlowe transaction output.
 * @export
 */
export type TransactionOutput = TxOutputError | TxOutputSuccess;

/**
 * @type TransactionWarning
 * A transaction semantics warning.
 * @export
 */
export type TransactionWarning = AssertFail | NonPositiveDeposit | NonPositivePayment | PartialPayment | VariableShadowing;

/**
 * 
 * @export
 * @interface Tx
 */
export interface Tx {
    /**
     * 
     * @type {Assets}
     * @memberof Tx
     */
    'assets': Assets;
    /**
     * 
     * @type {BlockHeader}
     * @memberof Tx
     */
    'block'?: BlockHeader;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Tx
     */
    'consumingTx'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'contractId': string;
    /**
     * 
     * @type {Array<Input>}
     * @memberof Tx
     */
    'inputs': Array<Input>;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'inputUtxo': string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'invalidBefore': string;
    /**
     * 
     * @type {string}
     * @memberof Tx
     */
    'invalidHereafter': string;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof Tx
     */
    'metadata': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {Contract}
     * @memberof Tx
     */
    'outputContract'?: Contract;
    /**
     * 
     * @type {MarloweState}
     * @memberof Tx
     */
    'outputState'?: MarloweState;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof Tx
     */
    'outputUtxo'?: string;
    /**
     * 
     * @type {Array<Payout>}
     * @memberof Tx
     */
    'payouts': Array<Payout>;
    /**
     * 
     * @type {TxStatus}
     * @memberof Tx
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof Tx
     */
    'tags': { [key: string]: Metadata | undefined; };
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Tx
     */
    'transactionId': string;
    /**
     * 
     * @type {TextEnvelope}
     * @memberof Tx
     */
    'txBody'?: TextEnvelope;
}


/**
 * 
 * @export
 * @interface TxHeader
 */
export interface TxHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof TxHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {string}
     * @memberof TxHeader
     */
    'continuations'?: string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof TxHeader
     */
    'contractId': string;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof TxHeader
     */
    'metadata': { [key: string]: Metadata | undefined; };
    /**
     * 
     * @type {TxStatus}
     * @memberof TxHeader
     */
    'status': TxStatus;
    /**
     * 
     * @type {{ [key: string]: Metadata | undefined; }}
     * @memberof TxHeader
     */
    'tags': { [key: string]: Metadata | undefined; };
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof TxHeader
     */
    'transactionId': string;
    /**
     * A reference to a transaction output with a transaction ID and index.
     * @type {string}
     * @memberof TxHeader
     */
    'utxo'?: string;
}


/**
 * Marlowe transaction error.
 * @export
 * @interface TxOutputError
 */
export interface TxOutputError {
    /**
     * 
     * @type {TransactionError}
     * @memberof TxOutputError
     */
    'transaction_error': TransactionError;
}
/**
 * Marlowe transaction output information.
 * @export
 * @interface TxOutputSuccess
 */
export interface TxOutputSuccess {
    /**
     * 
     * @type {Contract}
     * @memberof TxOutputSuccess
     */
    'contract': Contract;
    /**
     * 
     * @type {Array<Payment>}
     * @memberof TxOutputSuccess
     */
    'payments': Array<Payment>;
    /**
     * 
     * @type {MarloweState}
     * @memberof TxOutputSuccess
     */
    'state': MarloweState;
    /**
     * 
     * @type {Array<TransactionWarning>}
     * @memberof TxOutputSuccess
     */
    'warnings': Array<TransactionWarning>;
}
/**
 * The status of a transaction on the local node.
 * @export
 * @enum {string}
 */

export const TxStatus = {
    Unsigned: 'unsigned',
    Submitted: 'submitted',
    Confirmed: 'confirmed'
} as const;

export type TxStatus = typeof TxStatus[keyof typeof TxStatus];


/**
 * 
 * @export
 * @interface UseValue
 */
export interface UseValue {
    /**
     * 
     * @type {string}
     * @memberof UseValue
     */
    'use_value': string;
}
/**
 * @type Value
 * A time-varying expression that evaluates to a boolean
 * @export
 */
export type Value = Add | Divide | IfValue | Minus | Multiply | Negate | TimeInterval | TokenInAccount | UseValue | ValueOfChoice | number;

/**
 * @type ValueObject
 * A time-varying expression that evaluates to a boolean
 * @export
 */
export type ValueObject = AddObject | DivideObject | IfValueObject | LabelRef | MinusObject | MultiplyObject | NegateObject | TimeInterval | TokenInAccountObject | UseValue | ValueOfChoiceObject | number;

/**
 * 
 * @export
 * @interface ValueOfChoice
 */
export interface ValueOfChoice {
    /**
     * 
     * @type {ChoiceId}
     * @memberof ValueOfChoice
     */
    'value_of_choice': ChoiceId;
}
/**
 * 
 * @export
 * @interface ValueOfChoiceObject
 */
export interface ValueOfChoiceObject {
    /**
     * 
     * @type {ChoiceIdObject}
     * @memberof ValueOfChoiceObject
     */
    'value_of_choice': ChoiceIdObject;
}
/**
 * A variable-name shadowing warning.
 * @export
 * @interface VariableShadowing
 */
export interface VariableShadowing {
    /**
     * 
     * @type {number}
     * @memberof VariableShadowing
     */
    'had_value': number;
    /**
     * 
     * @type {number}
     * @memberof VariableShadowing
     */
    'is_now_assigned': number;
    /**
     * 
     * @type {string}
     * @memberof VariableShadowing
     */
    'value_id': string;
}
/**
 * Wait for an action to be performed and apply the matching contract when it does. Apply the timeout contract if no actions have been performed in the timeout period.
 * @export
 * @interface When
 */
export interface When {
    /**
     * 
     * @type {number}
     * @memberof When
     */
    'timeout': number;
    /**
     * 
     * @type {Contract}
     * @memberof When
     */
    'timeout_continuation': Contract;
    /**
     * 
     * @type {Array<Case>}
     * @memberof When
     */
    'when': Array<Case>;
}
/**
 * Wait for an action to be performed and apply the matching contract when it does. Apply the timeout contract if no actions have been performed in the timeout period.
 * @export
 * @interface WhenObject
 */
export interface WhenObject {
    /**
     * 
     * @type {number}
     * @memberof WhenObject
     */
    'timeout': number;
    /**
     * 
     * @type {ContractObject}
     * @memberof WhenObject
     */
    'timeout_continuation': ContractObject;
    /**
     * 
     * @type {Array<CaseObject>}
     * @memberof WhenObject
     */
    'when': Array<CaseObject>;
}
/**
 * 
 * @export
 * @interface WithdrawPayoutsResponse
 */
export interface WithdrawPayoutsResponse {
    /**
     * 
     * @type {GetWithdrawalsResponseResultsInnerLinks}
     * @memberof WithdrawPayoutsResponse
     */
    'links': GetWithdrawalsResponseResultsInnerLinks;
    /**
     * 
     * @type {WithdrawTxEnvelope}
     * @memberof WithdrawPayoutsResponse
     */
    'resource': WithdrawTxEnvelope;
}
/**
 * The \"type\" property of \"txBody\" must be \"TxBody BabbageEra\" or \"TxBody ConwayEra\"
 * @export
 * @interface WithdrawTxBodyEnvelope
 */
export interface WithdrawTxBodyEnvelope {
    /**
     * 
     * @type {TextEnvelope}
     * @memberof WithdrawTxBodyEnvelope
     */
    'txBody': TextEnvelope;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof WithdrawTxBodyEnvelope
     */
    'withdrawalId': string;
}
/**
 * The \"type\" property of \"tx\" must be \"Tx BabbageEra\" or \"Tx ConwayEra\"
 * @export
 * @interface WithdrawTxEnvelope
 */
export interface WithdrawTxEnvelope {
    /**
     * 
     * @type {TextEnvelope}
     * @memberof WithdrawTxEnvelope
     */
    'tx': TextEnvelope;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof WithdrawTxEnvelope
     */
    'withdrawalId': string;
}
/**
 * 
 * @export
 * @interface Withdrawal
 */
export interface Withdrawal {
    /**
     * 
     * @type {BlockHeader}
     * @memberof Withdrawal
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {Set<PayoutHeader>}
     * @memberof Withdrawal
     */
    'payouts': Set<PayoutHeader>;
    /**
     * 
     * @type {TxStatus}
     * @memberof Withdrawal
     */
    'status': TxStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof Withdrawal
     */
    'withdrawalId': string;
}


/**
 * 
 * @export
 * @interface WithdrawalHeader
 */
export interface WithdrawalHeader {
    /**
     * 
     * @type {BlockHeader}
     * @memberof WithdrawalHeader
     */
    'block'?: BlockHeader;
    /**
     * 
     * @type {TxStatus}
     * @memberof WithdrawalHeader
     */
    'status': TxStatus;
    /**
     * The hex-encoded identifier of a Cardano transaction
     * @type {string}
     * @memberof WithdrawalHeader
     */
    'withdrawalId': string;
}



/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
         * @summary Apply inputs to contract
         * @param {string} contractId 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostTransactionsRequest} [postTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyInputsToContract: async (contractId: string, xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postTransactionsRequest?: PostTransactionsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('applyInputsToContract', 'contractId', contractId)
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('applyInputsToContract', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/contracts/{contractId}/transactions`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postTransactionsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
         * @summary Create a new contract
         * @param {string} xChangeAddress 
         * @param {string} [xStakeAddress] Where to send staking rewards for the Marlowe script outputs of this contract.
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostContractsRequest} [postContractsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract: async (xChangeAddress: string, xStakeAddress?: string, xAddress?: string, xCollateralUTxO?: string, postContractsRequest?: PostContractsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('createContract', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xStakeAddress != null) {
                localVarHeaderParameter['X-Stake-Address'] = String(xStakeAddress);
            }

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postContractsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
         * @summary Upload contract sources
         * @param {string} main The label of the top-level contract object in the bundle(s).
         * @param {Array<LabelledObject>} [labelledObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractSources: async (main: string, labelledObject?: Array<LabelledObject>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'main' is not null or undefined
            assertParamExists('createContractSources', 'main', main)
            const localVarPath = `/contracts/sources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (main !== undefined) {
                localVarQueryParameter['main'] = main;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(labelledObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract by ID
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractById: async (contractId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractById', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
         * @summary Get adjacent contract source IDs by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceAdjacency: async (contractSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('getContractSourceAdjacency', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}/adjacency`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract source by ID
         * @param {string} contractSourceId 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceById: async (contractSourceId: string, expand?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('getContractSourceById', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (expand !== undefined) {
                localVarQueryParameter['expand'] = expand;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
         * @summary Get contract source closure by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceClosure: async (contractSourceId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractSourceId' is not null or undefined
            assertParamExists('getContractSourceClosure', 'contractSourceId', contractSourceId)
            const localVarPath = `/contracts/sources/{contractSourceId}/closure`
                .replace(`{${"contractSourceId"}}`, encodeURIComponent(String(contractSourceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get contract transaction by ID
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTransactionById: async (contractId: string, transactionId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getContractTransactionById', 'contractId', contractId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getContractTransactionById', 'transactionId', transactionId)
            const localVarPath = `/contracts/{contractId}/transactions/{transactionId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
         * @summary Get contracts
         * @param {Array<string>} [roleCurrency] 
         * @param {Array<string>} [tag] 
         * @param {Array<string>} [partyAddress] 
         * @param {Array<string>} [partyRole] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts: async (roleCurrency?: Array<string>, tag?: Array<string>, partyAddress?: Array<string>, partyRole?: Array<string>, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/contracts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleCurrency) {
                localVarQueryParameter['roleCurrency'] = roleCurrency;
            }

            if (tag) {
                localVarQueryParameter['tag'] = tag;
            }

            if (partyAddress) {
                localVarQueryParameter['partyAddress'] = partyAddress;
            }

            if (partyRole) {
                localVarQueryParameter['partyRole'] = partyRole;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get inputs which could be performed on a contract withing a time range by the requested parties.
         * @summary Get next contract steps
         * @param {string} contractId 
         * @param {string} validityStart The beginning of the validity range.
         * @param {string} validityEnd The end of the validity range.
         * @param {Array<string>} [party] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextStepsForContract: async (contractId: string, validityStart: string, validityEnd: string, party?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getNextStepsForContract', 'contractId', contractId)
            // verify required parameter 'validityStart' is not null or undefined
            assertParamExists('getNextStepsForContract', 'validityStart', validityStart)
            // verify required parameter 'validityEnd' is not null or undefined
            assertParamExists('getNextStepsForContract', 'validityEnd', validityEnd)
            const localVarPath = `/contracts/{contractId}/next`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (validityStart !== undefined) {
                localVarQueryParameter['validityStart'] = validityStart;
            }

            if (validityEnd !== undefined) {
                localVarQueryParameter['validityEnd'] = validityEnd;
            }

            if (party) {
                localVarQueryParameter['party'] = party;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get payout by ID
         * @param {string} payoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById: async (payoutId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payoutId' is not null or undefined
            assertParamExists('getPayoutById', 'payoutId', payoutId)
            const localVarPath = `/payouts/{payoutId}`
                .replace(`{${"payoutId"}}`, encodeURIComponent(String(payoutId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
         * @summary Get role payouts
         * @param {Array<string>} [contractId] 
         * @param {Array<string>} [roleToken] 
         * @param {GetPayoutsStatusEnum} [status] Whether to include available or withdrawn payouts in the results.
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayouts: async (contractId?: Array<string>, roleToken?: Array<string>, status?: GetPayoutsStatusEnum, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/payouts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (contractId) {
                localVarQueryParameter['contractId'] = contractId;
            }

            if (roleToken) {
                localVarQueryParameter['roleToken'] = roleToken;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
         * @summary Get transactions for contract
         * @param {string} contractId 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsForContract: async (contractId: string, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('getTransactionsForContract', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}/transactions`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get withdrawal by ID
         * @param {string} withdrawalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalById: async (withdrawalId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('getWithdrawalById', 'withdrawalId', withdrawalId)
            const localVarPath = `/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
         * @summary Get withdrawals
         * @param {Array<string>} [roleCurrency] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals: async (roleCurrency?: Array<string>, range?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (roleCurrency) {
                localVarQueryParameter['roleCurrency'] = roleCurrency;
            }

            if (range != null) {
                localVarHeaderParameter['Range'] = String(range);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the server is running and ready to respond to requests.
         * @summary Test server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/healthcheck`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
         * @summary Submit contract to chain
         * @param {string} contractId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContract: async (contractId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('submitContract', 'contractId', contractId)
            const localVarPath = `/contracts/{contractId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
         * @summary Submit contract input application
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContractTransaction: async (contractId: string, transactionId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'contractId' is not null or undefined
            assertParamExists('submitContractTransaction', 'contractId', contractId)
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('submitContractTransaction', 'transactionId', transactionId)
            const localVarPath = `/contracts/{contractId}/transactions/{transactionId}`
                .replace(`{${"contractId"}}`, encodeURIComponent(String(contractId)))
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
         * @summary Submit payout withdrawal
         * @param {string} withdrawalId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWithdrawal: async (withdrawalId: string, textEnvelope?: TextEnvelope, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawalId' is not null or undefined
            assertParamExists('submitWithdrawal', 'withdrawalId', withdrawalId)
            const localVarPath = `/withdrawals/{withdrawalId}`
                .replace(`{${"withdrawalId"}}`, encodeURIComponent(String(withdrawalId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textEnvelope, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
         * @summary Withdraw payouts
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostWithdrawalsRequest} [postWithdrawalsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawPayouts: async (xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postWithdrawalsRequest?: PostWithdrawalsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xChangeAddress' is not null or undefined
            assertParamExists('withdrawPayouts', 'xChangeAddress', xChangeAddress)
            const localVarPath = `/withdrawals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (xChangeAddress != null) {
                localVarHeaderParameter['X-Change-Address'] = String(xChangeAddress);
            }

            if (xAddress != null) {
                localVarHeaderParameter['X-Address'] = String(xAddress);
            }

            if (xCollateralUTxO != null) {
                localVarHeaderParameter['X-Collateral-UTxO'] = String(xCollateralUTxO);
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json;charset=utf-8';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(postWithdrawalsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
         * @summary Apply inputs to contract
         * @param {string} contractId 
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostTransactionsRequest} [postTransactionsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async applyInputsToContract(contractId: string, xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postTransactionsRequest?: PostTransactionsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ApplyInputsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.applyInputsToContract(contractId, xChangeAddress, xAddress, xCollateralUTxO, postTransactionsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.applyInputsToContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
         * @summary Create a new contract
         * @param {string} xChangeAddress 
         * @param {string} [xStakeAddress] Where to send staking rewards for the Marlowe script outputs of this contract.
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostContractsRequest} [postContractsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContract(xChangeAddress: string, xStakeAddress?: string, xAddress?: string, xCollateralUTxO?: string, postContractsRequest?: PostContractsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContract(xChangeAddress, xStakeAddress, xAddress, xCollateralUTxO, postContractsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.createContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
         * @summary Upload contract sources
         * @param {string} main The label of the top-level contract object in the bundle(s).
         * @param {Array<LabelledObject>} [labelledObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContractSources(main: string, labelledObject?: Array<LabelledObject>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostContractSourceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContractSources(main, labelledObject, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.createContractSources']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get contract by ID
         * @param {string} contractId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractById(contractId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractById(contractId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
         * @summary Get adjacent contract source IDs by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractSourceAdjacency(contractSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSourceIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractSourceAdjacency(contractSourceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractSourceAdjacency']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get contract source by ID
         * @param {string} contractSourceId 
         * @param {boolean} [expand] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractSourceById(contractSourceId: string, expand?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Contract>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractSourceById(contractSourceId, expand, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractSourceById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
         * @summary Get contract source closure by ID
         * @param {string} contractSourceId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractSourceClosure(contractSourceId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContractSourceIds>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractSourceClosure(contractSourceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractSourceClosure']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get contract transaction by ID
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContractTransactionById(contractId: string, transactionId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContractTransactionById(contractId, transactionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContractTransactionById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
         * @summary Get contracts
         * @param {Array<string>} [roleCurrency] 
         * @param {Array<string>} [tag] 
         * @param {Array<string>} [partyAddress] 
         * @param {Array<string>} [partyRole] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContracts(roleCurrency?: Array<string>, tag?: Array<string>, partyAddress?: Array<string>, partyRole?: Array<string>, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContractsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContracts(roleCurrency, tag, partyAddress, partyRole, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getContracts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get inputs which could be performed on a contract withing a time range by the requested parties.
         * @summary Get next contract steps
         * @param {string} contractId 
         * @param {string} validityStart The beginning of the validity range.
         * @param {string} validityEnd The end of the validity range.
         * @param {Array<string>} [party] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNextStepsForContract(contractId: string, validityStart: string, validityEnd: string, party?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Next>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNextStepsForContract(contractId, validityStart, validityEnd, party, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getNextStepsForContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get payout by ID
         * @param {string} payoutId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayoutById(payoutId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayoutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayoutById(payoutId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getPayoutById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
         * @summary Get role payouts
         * @param {Array<string>} [contractId] 
         * @param {Array<string>} [roleToken] 
         * @param {GetPayoutsStatusEnum} [status] Whether to include available or withdrawn payouts in the results.
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPayouts(contractId?: Array<string>, roleToken?: Array<string>, status?: GetPayoutsStatusEnum, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetPayoutsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPayouts(contractId, roleToken, status, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getPayouts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
         * @summary Get transactions for contract
         * @param {string} contractId 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionsForContract(contractId: string, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetTransactionsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionsForContract(contractId, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getTransactionsForContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @summary Get withdrawal by ID
         * @param {string} withdrawalId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawalById(withdrawalId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Withdrawal>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawalById(withdrawalId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getWithdrawalById']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
         * @summary Get withdrawals
         * @param {Array<string>} [roleCurrency] 
         * @param {string} [range] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWithdrawals(roleCurrency?: Array<string>, range?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWithdrawalsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWithdrawals(roleCurrency, range, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.getWithdrawals']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if the server is running and ready to respond to requests.
         * @summary Test server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async healthcheck(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.healthcheck(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.healthcheck']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
         * @summary Submit contract to chain
         * @param {string} contractId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitContract(contractId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitContract(contractId, textEnvelope, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.submitContract']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
         * @summary Submit contract input application
         * @param {string} contractId 
         * @param {string} transactionId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitContractTransaction(contractId: string, transactionId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitContractTransaction(contractId, transactionId, textEnvelope, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.submitContractTransaction']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
         * @summary Submit payout withdrawal
         * @param {string} withdrawalId 
         * @param {TextEnvelope} [textEnvelope] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submitWithdrawal(withdrawalId: string, textEnvelope?: TextEnvelope, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submitWithdrawal(withdrawalId, textEnvelope, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.submitWithdrawal']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
         * @summary Withdraw payouts
         * @param {string} xChangeAddress 
         * @param {string} [xAddress] 
         * @param {string} [xCollateralUTxO] 
         * @param {PostWithdrawalsRequest} [postWithdrawalsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async withdrawPayouts(xChangeAddress: string, xAddress?: string, xCollateralUTxO?: string, postWithdrawalsRequest?: PostWithdrawalsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WithdrawPayoutsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.withdrawPayouts(xChangeAddress, xAddress, xCollateralUTxO, postWithdrawalsRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultApi.withdrawPayouts']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
         * @summary Apply inputs to contract
         * @param {DefaultApiApplyInputsToContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        applyInputsToContract(requestParameters: DefaultApiApplyInputsToContractRequest, options?: AxiosRequestConfig): AxiosPromise<ApplyInputsResponse> {
            return localVarFp.applyInputsToContract(requestParameters.contractId, requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postTransactionsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
         * @summary Create a new contract
         * @param {DefaultApiCreateContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContract(requestParameters: DefaultApiCreateContractRequest, options?: AxiosRequestConfig): AxiosPromise<CreateContractResponse> {
            return localVarFp.createContract(requestParameters.xChangeAddress, requestParameters.xStakeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postContractsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
         * @summary Upload contract sources
         * @param {DefaultApiCreateContractSourcesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContractSources(requestParameters: DefaultApiCreateContractSourcesRequest, options?: AxiosRequestConfig): AxiosPromise<PostContractSourceResponse> {
            return localVarFp.createContractSources(requestParameters.main, requestParameters.labelledObject, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract by ID
         * @param {DefaultApiGetContractByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractById(requestParameters: DefaultApiGetContractByIdRequest, options?: AxiosRequestConfig): AxiosPromise<GetContractResponse> {
            return localVarFp.getContractById(requestParameters.contractId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
         * @summary Get adjacent contract source IDs by ID
         * @param {DefaultApiGetContractSourceAdjacencyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceAdjacency(requestParameters: DefaultApiGetContractSourceAdjacencyRequest, options?: AxiosRequestConfig): AxiosPromise<ContractSourceIds> {
            return localVarFp.getContractSourceAdjacency(requestParameters.contractSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract source by ID
         * @param {DefaultApiGetContractSourceByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceById(requestParameters: DefaultApiGetContractSourceByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Contract> {
            return localVarFp.getContractSourceById(requestParameters.contractSourceId, requestParameters.expand, options).then((request) => request(axios, basePath));
        },
        /**
         * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
         * @summary Get contract source closure by ID
         * @param {DefaultApiGetContractSourceClosureRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractSourceClosure(requestParameters: DefaultApiGetContractSourceClosureRequest, options?: AxiosRequestConfig): AxiosPromise<ContractSourceIds> {
            return localVarFp.getContractSourceClosure(requestParameters.contractSourceId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get contract transaction by ID
         * @param {DefaultApiGetContractTransactionByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContractTransactionById(requestParameters: DefaultApiGetContractTransactionByIdRequest, options?: AxiosRequestConfig): AxiosPromise<GetTransactionResponse> {
            return localVarFp.getContractTransactionById(requestParameters.contractId, requestParameters.transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
         * @summary Get contracts
         * @param {DefaultApiGetContractsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContracts(requestParameters: DefaultApiGetContractsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetContractsResponse> {
            return localVarFp.getContracts(requestParameters.roleCurrency, requestParameters.tag, requestParameters.partyAddress, requestParameters.partyRole, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Get inputs which could be performed on a contract withing a time range by the requested parties.
         * @summary Get next contract steps
         * @param {DefaultApiGetNextStepsForContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextStepsForContract(requestParameters: DefaultApiGetNextStepsForContractRequest, options?: AxiosRequestConfig): AxiosPromise<Next> {
            return localVarFp.getNextStepsForContract(requestParameters.contractId, requestParameters.validityStart, requestParameters.validityEnd, requestParameters.party, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get payout by ID
         * @param {DefaultApiGetPayoutByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayoutById(requestParameters: DefaultApiGetPayoutByIdRequest, options?: AxiosRequestConfig): AxiosPromise<GetPayoutResponse> {
            return localVarFp.getPayoutById(requestParameters.payoutId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
         * @summary Get role payouts
         * @param {DefaultApiGetPayoutsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPayouts(requestParameters: DefaultApiGetPayoutsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetPayoutsResponse> {
            return localVarFp.getPayouts(requestParameters.contractId, requestParameters.roleToken, requestParameters.status, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
         * @summary Get transactions for contract
         * @param {DefaultApiGetTransactionsForContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionsForContract(requestParameters: DefaultApiGetTransactionsForContractRequest, options?: AxiosRequestConfig): AxiosPromise<GetTransactionsResponse> {
            return localVarFp.getTransactionsForContract(requestParameters.contractId, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get withdrawal by ID
         * @param {DefaultApiGetWithdrawalByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawalById(requestParameters: DefaultApiGetWithdrawalByIdRequest, options?: AxiosRequestConfig): AxiosPromise<Withdrawal> {
            return localVarFp.getWithdrawalById(requestParameters.withdrawalId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
         * @summary Get withdrawals
         * @param {DefaultApiGetWithdrawalsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWithdrawals(requestParameters: DefaultApiGetWithdrawalsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<GetWithdrawalsResponse> {
            return localVarFp.getWithdrawals(requestParameters.roleCurrency, requestParameters.range, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the server is running and ready to respond to requests.
         * @summary Test server status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        healthcheck(options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.healthcheck(options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
         * @summary Submit contract to chain
         * @param {DefaultApiSubmitContractRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContract(requestParameters: DefaultApiSubmitContractRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitContract(requestParameters.contractId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
         * @summary Submit contract input application
         * @param {DefaultApiSubmitContractTransactionRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitContractTransaction(requestParameters: DefaultApiSubmitContractTransactionRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitContractTransaction(requestParameters.contractId, requestParameters.transactionId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
         * @summary Submit payout withdrawal
         * @param {DefaultApiSubmitWithdrawalRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submitWithdrawal(requestParameters: DefaultApiSubmitWithdrawalRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.submitWithdrawal(requestParameters.withdrawalId, requestParameters.textEnvelope, options).then((request) => request(axios, basePath));
        },
        /**
         * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
         * @summary Withdraw payouts
         * @param {DefaultApiWithdrawPayoutsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        withdrawPayouts(requestParameters: DefaultApiWithdrawPayoutsRequest, options?: AxiosRequestConfig): AxiosPromise<WithdrawPayoutsResponse> {
            return localVarFp.withdrawPayouts(requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postWithdrawalsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for applyInputsToContract operation in DefaultApi.
 * @export
 * @interface DefaultApiApplyInputsToContractRequest
 */
export interface DefaultApiApplyInputsToContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly xChangeAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostTransactionsRequest}
     * @memberof DefaultApiApplyInputsToContract
     */
    readonly postTransactionsRequest?: PostTransactionsRequest
}

/**
 * Request parameters for createContract operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateContractRequest
 */
export interface DefaultApiCreateContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xChangeAddress: string

    /**
     * Where to send staking rewards for the Marlowe script outputs of this contract.
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xStakeAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiCreateContract
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostContractsRequest}
     * @memberof DefaultApiCreateContract
     */
    readonly postContractsRequest?: PostContractsRequest
}

/**
 * Request parameters for createContractSources operation in DefaultApi.
 * @export
 * @interface DefaultApiCreateContractSourcesRequest
 */
export interface DefaultApiCreateContractSourcesRequest {
    /**
     * The label of the top-level contract object in the bundle(s).
     * @type {string}
     * @memberof DefaultApiCreateContractSources
     */
    readonly main: string

    /**
     * 
     * @type {Array<LabelledObject>}
     * @memberof DefaultApiCreateContractSources
     */
    readonly labelledObject?: Array<LabelledObject>
}

/**
 * Request parameters for getContractById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractByIdRequest
 */
export interface DefaultApiGetContractByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractById
     */
    readonly contractId: string
}

/**
 * Request parameters for getContractSourceAdjacency operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractSourceAdjacencyRequest
 */
export interface DefaultApiGetContractSourceAdjacencyRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractSourceAdjacency
     */
    readonly contractSourceId: string
}

/**
 * Request parameters for getContractSourceById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractSourceByIdRequest
 */
export interface DefaultApiGetContractSourceByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractSourceById
     */
    readonly contractSourceId: string

    /**
     * 
     * @type {boolean}
     * @memberof DefaultApiGetContractSourceById
     */
    readonly expand?: boolean
}

/**
 * Request parameters for getContractSourceClosure operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractSourceClosureRequest
 */
export interface DefaultApiGetContractSourceClosureRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractSourceClosure
     */
    readonly contractSourceId: string
}

/**
 * Request parameters for getContractTransactionById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractTransactionByIdRequest
 */
export interface DefaultApiGetContractTransactionByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractTransactionById
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContractTransactionById
     */
    readonly transactionId: string
}

/**
 * Request parameters for getContracts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetContractsRequest
 */
export interface DefaultApiGetContractsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly roleCurrency?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly tag?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly partyAddress?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetContracts
     */
    readonly partyRole?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetContracts
     */
    readonly range?: string
}

/**
 * Request parameters for getNextStepsForContract operation in DefaultApi.
 * @export
 * @interface DefaultApiGetNextStepsForContractRequest
 */
export interface DefaultApiGetNextStepsForContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly contractId: string

    /**
     * The beginning of the validity range.
     * @type {string}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly validityStart: string

    /**
     * The end of the validity range.
     * @type {string}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly validityEnd: string

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetNextStepsForContract
     */
    readonly party?: Array<string>
}

/**
 * Request parameters for getPayoutById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPayoutByIdRequest
 */
export interface DefaultApiGetPayoutByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetPayoutById
     */
    readonly payoutId: string
}

/**
 * Request parameters for getPayouts operation in DefaultApi.
 * @export
 * @interface DefaultApiGetPayoutsRequest
 */
export interface DefaultApiGetPayoutsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetPayouts
     */
    readonly contractId?: Array<string>

    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetPayouts
     */
    readonly roleToken?: Array<string>

    /**
     * Whether to include available or withdrawn payouts in the results.
     * @type {'available' | 'withdrawn'}
     * @memberof DefaultApiGetPayouts
     */
    readonly status?: GetPayoutsStatusEnum

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetPayouts
     */
    readonly range?: string
}

/**
 * Request parameters for getTransactionsForContract operation in DefaultApi.
 * @export
 * @interface DefaultApiGetTransactionsForContractRequest
 */
export interface DefaultApiGetTransactionsForContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetTransactionsForContract
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetTransactionsForContract
     */
    readonly range?: string
}

/**
 * Request parameters for getWithdrawalById operation in DefaultApi.
 * @export
 * @interface DefaultApiGetWithdrawalByIdRequest
 */
export interface DefaultApiGetWithdrawalByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetWithdrawalById
     */
    readonly withdrawalId: string
}

/**
 * Request parameters for getWithdrawals operation in DefaultApi.
 * @export
 * @interface DefaultApiGetWithdrawalsRequest
 */
export interface DefaultApiGetWithdrawalsRequest {
    /**
     * 
     * @type {Array<string>}
     * @memberof DefaultApiGetWithdrawals
     */
    readonly roleCurrency?: Array<string>

    /**
     * 
     * @type {string}
     * @memberof DefaultApiGetWithdrawals
     */
    readonly range?: string
}

/**
 * Request parameters for submitContract operation in DefaultApi.
 * @export
 * @interface DefaultApiSubmitContractRequest
 */
export interface DefaultApiSubmitContractRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitContract
     */
    readonly contractId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiSubmitContract
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for submitContractTransaction operation in DefaultApi.
 * @export
 * @interface DefaultApiSubmitContractTransactionRequest
 */
export interface DefaultApiSubmitContractTransactionRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitContractTransaction
     */
    readonly contractId: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitContractTransaction
     */
    readonly transactionId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiSubmitContractTransaction
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for submitWithdrawal operation in DefaultApi.
 * @export
 * @interface DefaultApiSubmitWithdrawalRequest
 */
export interface DefaultApiSubmitWithdrawalRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiSubmitWithdrawal
     */
    readonly withdrawalId: string

    /**
     * 
     * @type {TextEnvelope}
     * @memberof DefaultApiSubmitWithdrawal
     */
    readonly textEnvelope?: TextEnvelope
}

/**
 * Request parameters for withdrawPayouts operation in DefaultApi.
 * @export
 * @interface DefaultApiWithdrawPayoutsRequest
 */
export interface DefaultApiWithdrawPayoutsRequest {
    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly xChangeAddress: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly xAddress?: string

    /**
     * 
     * @type {string}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly xCollateralUTxO?: string

    /**
     * 
     * @type {PostWithdrawalsRequest}
     * @memberof DefaultApiWithdrawPayouts
     */
    readonly postWithdrawalsRequest?: PostWithdrawalsRequest
}

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * Build an unsigned (Cardano) transaction body which applies inputs to an open Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId}/transactions/{transactionId} endpoint.
     * @summary Apply inputs to contract
     * @param {DefaultApiApplyInputsToContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public applyInputsToContract(requestParameters: DefaultApiApplyInputsToContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).applyInputsToContract(requestParameters.contractId, requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postTransactionsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Build an unsigned (Cardano) transaction body which opens a new Marlowe contract. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /contracts/{contractId} endpoint.
     * @summary Create a new contract
     * @param {DefaultApiCreateContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createContract(requestParameters: DefaultApiCreateContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createContract(requestParameters.xChangeAddress, requestParameters.xStakeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postContractsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a bundle of marlowe objects as contract sources. This API supports request body streaming, with newline framing between request bundles.
     * @summary Upload contract sources
     * @param {DefaultApiCreateContractSourcesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createContractSources(requestParameters: DefaultApiCreateContractSourcesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createContractSources(requestParameters.main, requestParameters.labelledObject, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract by ID
     * @param {DefaultApiGetContractByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractById(requestParameters: DefaultApiGetContractByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractById(requestParameters.contractId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the contract source IDs which are adjacent to a contract source (they appear directly in the contract source).
     * @summary Get adjacent contract source IDs by ID
     * @param {DefaultApiGetContractSourceAdjacencyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractSourceAdjacency(requestParameters: DefaultApiGetContractSourceAdjacencyRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractSourceAdjacency(requestParameters.contractSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract source by ID
     * @param {DefaultApiGetContractSourceByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractSourceById(requestParameters: DefaultApiGetContractSourceByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractSourceById(requestParameters.contractSourceId, requestParameters.expand, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get the contract source IDs which appear in the full hierarchy of a contract source (including the ID of the contract source its self).
     * @summary Get contract source closure by ID
     * @param {DefaultApiGetContractSourceClosureRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractSourceClosure(requestParameters: DefaultApiGetContractSourceClosureRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractSourceClosure(requestParameters.contractSourceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get contract transaction by ID
     * @param {DefaultApiGetContractTransactionByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContractTransactionById(requestParameters: DefaultApiGetContractTransactionByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContractTransactionById(requestParameters.contractId, requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get contracts published on chain. Results are returned in pages, with paging being specified by request headers.
     * @summary Get contracts
     * @param {DefaultApiGetContractsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getContracts(requestParameters: DefaultApiGetContractsRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getContracts(requestParameters.roleCurrency, requestParameters.tag, requestParameters.partyAddress, requestParameters.partyRole, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get inputs which could be performed on a contract withing a time range by the requested parties.
     * @summary Get next contract steps
     * @param {DefaultApiGetNextStepsForContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNextStepsForContract(requestParameters: DefaultApiGetNextStepsForContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNextStepsForContract(requestParameters.contractId, requestParameters.validityStart, requestParameters.validityEnd, requestParameters.party, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get payout by ID
     * @param {DefaultApiGetPayoutByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPayoutById(requestParameters: DefaultApiGetPayoutByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPayoutById(requestParameters.payoutId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get payouts to parties from role-based contracts. Results are returned in pages, with paging being specified by request headers.
     * @summary Get role payouts
     * @param {DefaultApiGetPayoutsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPayouts(requestParameters: DefaultApiGetPayoutsRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPayouts(requestParameters.contractId, requestParameters.roleToken, requestParameters.status, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get published transactions for a contract. Results are returned in pages, with paging being specified by request headers.
     * @summary Get transactions for contract
     * @param {DefaultApiGetTransactionsForContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getTransactionsForContract(requestParameters: DefaultApiGetTransactionsForContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getTransactionsForContract(requestParameters.contractId, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get withdrawal by ID
     * @param {DefaultApiGetWithdrawalByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWithdrawalById(requestParameters: DefaultApiGetWithdrawalByIdRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWithdrawalById(requestParameters.withdrawalId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get published withdrawal transactions. Results are returned in pages, with paging being specified by request headers.
     * @summary Get withdrawals
     * @param {DefaultApiGetWithdrawalsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getWithdrawals(requestParameters: DefaultApiGetWithdrawalsRequest = {}, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getWithdrawals(requestParameters.roleCurrency, requestParameters.range, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the server is running and ready to respond to requests.
     * @summary Test server status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public healthcheck(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).healthcheck(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed (Cardano) transaction that opens a new Marlowe contract. The transaction must have originally been created by the POST /contracts endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId} endpoint to poll the on-chain status.
     * @summary Submit contract to chain
     * @param {DefaultApiSubmitContractRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitContract(requestParameters: DefaultApiSubmitContractRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitContract(requestParameters.contractId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed (Cardano) transaction that applies inputs to an open Marlowe contract. The transaction must have originally been created by the POST /contracts/{contractId}/transactions endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /contracts/{contractId}/transactions/{transactionId} endpoint to poll the on-chain status.
     * @summary Submit contract input application
     * @param {DefaultApiSubmitContractTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitContractTransaction(requestParameters: DefaultApiSubmitContractTransactionRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitContractTransaction(requestParameters.contractId, requestParameters.transactionId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a signed (Cardano) transaction that withdraws available payouts from a role payout validator. The transaction must have originally been created by the POST /withdrawals endpoint. This endpoint will respond when the transaction is submitted successfully to the local node, which means it will not wait for the transaction to be published in a block. Use the GET /withdrawals/{withdrawalId} endpoint to poll the on-chain status.
     * @summary Submit payout withdrawal
     * @param {DefaultApiSubmitWithdrawalRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public submitWithdrawal(requestParameters: DefaultApiSubmitWithdrawalRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).submitWithdrawal(requestParameters.withdrawalId, requestParameters.textEnvelope, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Build an unsigned (Cardano) transaction body which withdraws available payouts from a role payout validator. This unsigned transaction must be signed by a wallet (such as a CIP-30 or CIP-45 wallet) before being submitted. To submit the signed transaction, use the PUT /withdrawals/{withdrawalId} endpoint.
     * @summary Withdraw payouts
     * @param {DefaultApiWithdrawPayoutsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public withdrawPayouts(requestParameters: DefaultApiWithdrawPayoutsRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).withdrawPayouts(requestParameters.xChangeAddress, requestParameters.xAddress, requestParameters.xCollateralUTxO, requestParameters.postWithdrawalsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetPayoutsStatusEnum = {
    Available: 'available',
    Withdrawn: 'withdrawn'
} as const;
export type GetPayoutsStatusEnum = typeof GetPayoutsStatusEnum[keyof typeof GetPayoutsStatusEnum];


